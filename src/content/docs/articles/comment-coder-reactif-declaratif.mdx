---
title: Comment coder de mani√®re r√©active et d√©clarative
description: Comment coder de mani√®re r√©active et d√©clarative
---

:::note
Cette article existe √©galement sur [Medium](https://medium.com/@kevin.tale/comment-coder-de-mani%C3%A8re-r%C3%A9active-et-d%C3%A9clarative-en-angular-a698b95da9f6). <br />
S'il vous a plu, n'h√©sitez pas √† me laisser un (ou plusieurs) petit clap üòâ
:::

Un conseil que l'on voit souvent dans les bonnes pratiques Angular, c'est de coder de mani√®re r√©active et d√©clarative.

Pour √™tre honn√™te, je crois bien que c'est l'une des comp√©tences les plus importantes √† avoir lorsque l'on fait du d√©veloppement d'applications Angular.

Quand on programme de mani√®re r√©active et d√©clarative, notre code devient plus pr√©visible, plus explicite et moins verbeux. De ce fait, on arrive √† produire plus rapidement et de mani√®re plus agr√©able.

C'est un v√©ritable √©tat d'esprit √† avoir, et quand on l'a, on n'a plus envie de faire marche arri√®re tant le gain est √©vident.

C'est bon, je vous ai assez vendu le truc comme √ßa¬†? Tr√®s bien. Alors r√©pondons √† cette phrase¬†: que veut dire "programmer de mani√®re r√©active et d√©clarative"¬†?

---

D√©marrons avec ce composant.

```typescript
@Component({
  template: `
    <p>{{ celsius }}</p>
    <p>{{ fahrenheit }}</p>
    <button (click)="doubleCelsius()">Doubler celsius</button>
  `,
})
export class SomeComponent {
  celsius = 25;
  fahrenheit = this.celsius * 1.8 + 32;

  doubleCelsius() {
    this.celsius = this.celsius * 2;
  }
}
```

A l'√©tat initial, j'affiche des degr√©s Celsius et son √©quivalent en Fahrenheit. Au clique sur le bouton, je double le degr√© Celsius.

L'objectif est simple, j'aimerais que fahrenheit soit toujours √©gal √† son √©quivalent en Celsius m√™me si ce dernier change.

Maintenant, je clique sur `Doubler Celsius`.

Question¬†: est-ce que `fahrenheit` a chang√©¬†?
R√©ponse¬†: non¬†!

Et apr√®s tout c'est logique, `fahrenheit` n'est interpr√©t√© que lors de l'initialisation du composant. Donc √† sa cr√©ation il se base sur `celsius` mais plus tard m√™me si `celsius` change, ce n'est pas le cas de `fahrenheit`.

On dit que `fahrenheit` n'est pas **r√©actif**, il ne r√©agit pas lorsque ses d√©pendances changent.

Une fa√ßon de r√©gler le probl√®me pourrait √™tre ceci.

```typescript
...
doubleCelsius() {
    this.celsius = this.celsius * 2;
    this.fahrenheit = this.celsius * 1.8 + 32;
}
...
```

Mais vous voyez vite les probl√®mes¬†:

- La Single Responsibility Principle est bris√©e car la fonction fait plus que ce qu'elle pr√©tend faire
- Il est facile d'oublier de mettre √† jour une donn√©e qui d√©pendrait de `celsius`
- Il est compliqu√© de suivre "l'√©tat de vie" de `fahrenheit` car il est modifi√© √† divers endroit de mon fichier

Ce dernier point est important car c'est ce qui cr√©e rapidement l'effet "spaghetti code", c'est √† dire un code o√π il faut parcourir plusieurs m√©thodes voire fichiers pour d√©terminer le flux de fonctionnement principal.

L√† mon cas est simple mais imaginez dans une vraie applications avec des centaines de composants, services etc‚Ä¶

### La programmation r√©active et d√©clarative √† la rescousse¬†!

La programmation r√©active fera en sorte que `fahrenheit` r√©agisse automatiquement lorsque `celsius` changera. Et la programmation d√©clarative rendra ce code facilement compr√©hensible.

Et les Signal sont parfait pour √ßa¬†!

```typescript
@Component({
  template: `
    <p>{{ celsius() }}</p>
    <p>{{ fahrenheit() }}</p>
    <button (click)="doubleCelsius()">Doubler celsius</button>
  `,
})
export class SomeComponent {
  celsius = signal(25);
  fahrenheit = computed(() => this.celsius() * 1.8 + 32);

  doubleCelsius() {
    this.celsius.update((celsius) => celsius * 2);
  }
}
```

Ici, `celsius` est un Signal, je le modifie avec la m√©thode¬†`.update()`. `fahrenheit` est d√©finie gr√¢ce √† `computed`.

D√®s qu'un Signal est utilis√© dans `computed()` celui-ci est enregistr√© en tant que d√©pendance. Ainsi, lorsque l'une de ses d√©pendances est modifi√©es alors `computed()` se recalcule, permettant ainsi de r√©agir aux changements automatiquement¬†! C'est donc tr√®s pratique pour cr√©er des valeurs d√©riv√©es et est une repr√©sentation parfaite d'un code r√©actif.

Mais en quoi est-ce un code d√©claratif¬†?

Et bien, je disais plus haut que le code d√©claratif est plus facile √† comprendre. C'est le cas ici. Dans la d√©claration de `fahrenheit` j'y d√©cris tout son cycle de vie, je n'ai pas √† √©crire √©tape par √©tape ce qu'il advient de cette propri√©t√©. Je me repose sur des abstractions, en l'occurrence `computed`.

On retrouve √©galement √ßa avec les m√©thodes des tableaux en JS.

```typescript
Code Imp√©ratif
let numbers = [1, 2, 3, 4, 5];
let oddNumbers = [];

for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 !== 0) {
        oddNumbers.push(numbers[i]);
    }
}

// Code D√©claratif
let numbers = [1, 2, 3, 4, 5];
let oddNumbers = numbers.filter(num => num % 2 !== 0);
```

La plupart du temps la programmation d√©clarative consiste √† se reposer sur des fonctions d√©j√† existantes pour obtenir ce que l'on veut. C'est le cas ici avec `filter` ou avec les Signals et `computed`.

Un autre exemple avec les Signal.

```typescript
@Component({
  template: `
    ...
    <input
      type="text"
      placeholder="Filter products"
      (input)="setFilter($event)"
    />
    ...
  `
})
export class ProductsComponent {
  #products = signal([...]);
  #filter = signal('');

  filteredProducts = computed(() =>
    this.#products().filter(product => product.includes(this.#filter()))
  );
  isFilteredProductsEmpty = computed(
    () => this.filteredProducts().length === 0
  );

  setFilter(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.#filter.set(input.value);
  }
}
```

Comme vous le voyez, il est tr√®s facile de faire des "cascades" de r√©activit√©. C‚Äôest le cas ici car `setFilter` fait uniquement ce qu‚Äôil pr√©tend faire : changer le filtre. Puis tout les changements suivants surviennent en cascade.

Voyez sa version imp√©rative (√† ne pas reproduire chez soi¬†!)

```typescript
@Component({
  template: `
    ...
    <input
      type="text"
      placeholder="Filter products"
      (input)="setFilter($event)"
    />
    ...
  `
})
export class ProductsComponent {
  private products: string[] = [...];
  private filter: string = '';

  public filteredProducts: string[] = this.products;
  public isFilteredProductsEmpty: boolean = this.products.length === 0;

  setFilter(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.filter = input.value;
    this.updateFilteredProducts();
    this.checkIfFilteredProductsEmpty();
  }

  private updateFilteredProducts(): void {
    this.filteredProducts = this.products.filter(product => product.includes(this.filter));
  }

  private checkIfFilteredProductsEmpty(): void {
    this.isFilteredProductsEmpty = this.filteredProducts.length === 0;
  }
}
```

La version d√©clarative et r√©active offre donc un avantage tr√®s clair en terme de lecture et de pr√©dictibilit√©. Il est moins ais√© d‚Äôintroduire des effets de bords ou d‚Äôoublier de mettre √† jour certaines donn√©es.

### Un exemple avec¬†RxJS

```typescript
@Component({...})
export class ProductComponent {
  route = inject(ActivatedRoute);
  productService = inject(ProductService);

  product$ = this.route.params.pipe(
    switchMap(params => this.productService.getProductById(params['id']))
  );
}
```

Ce code est √† la fois r√©actif et d√©claratif car il me suffit de lire la propri√©t√© `product$` pour comprendre ce qui le constitue, je ne la r√©assigne jamais. Et il est r√©actif car il se repose sur RxJS et plus particuli√®rement l'Observable `params` qui vient de `ActivatedRoute`. D√®s que l‚Äôid va changer alors `params` va √©mettre une nouvelle donn√©e dans son flux et donc cela va rentrer dans mon `switchMap` qui va faire un nouveau call HTTP.

Je peux m√™me renforcer le fait que je veux du code d√©claratif en mettant la propri√©t√© en readonly¬†:

```typescript
readonly product$ = this.route.params.pipe(
  switchMap(params => this.productService.getProductById(params['id']))
);
```

Ainsi, je suis certain qu'il n'y a pas d'effet de bord possible, mon code est plus robuste et pr√©visible.

### Un code r√©actif mais pas d√©claratif

M√™me si les deux notions sont tr√®s souvent associ√©es, vous pouvez faire du code r√©actif mais pas d√©claratif.

```typescript
@Component({...})
export class ProductComponent {
  route = inject(ActivatedRoute);
  productService = inject(ProductService);

  product!: Product;

  constructor() {
    this.route.params.pipe(
      switchMap(params => this.productService.getProductById(params['id']))
    ).subscribe(product => this.product = product);
  }
}
```

Ce code se retrouve beaucoup dans les applications Angular. `product` est r√©assign√©e dans le `subscribe()`, je suis donc typiquement dans du code imp√©ratif o√π je d√©cris √©tape par √©tape ce qu'il advient de ma propri√©t√©. Cela rend le code plus verbeux et √ßa cr√©√© un `subscribe` manuel l√† o√π un `| async` ou `toSignal` serait plus judicieux.

### Conclusion

Si je devais r√©sumer ces deux termes, je dirais¬†:

- La programmation r√©active consiste √† cr√©er du code qui r√©agit lorsque des donn√©es changent ou lorsqu'un √©v√®nement survient.
- La programmation d√©clarative consiste √† d√©crire ce que l'on souhaite obtenir sans pr√©ciser les √©tapes d√©taill√©es pour y parvenir.

Pour √™tre efficaces, vos applications doivent √™tre construites sur une logique r√©active et d√©clarative, vous devez penser "√©v√®nements" et "flux de donn√©es", cela √©vitera le spaghetti code et donc retardera le legacy¬†!
