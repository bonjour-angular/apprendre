---
title: Avez-vous besoin de NgRx ?
description: Avez-vous besoin de NgRx ?
---

:::note
Cette article existe Ã©galement sur [Medium](https://medium.com/@kevin.tale/avez-vous-besoin-de-ngrx-3a09a02cea28).

S'il vous a plu, n'hÃ©sitez pas Ã  me laisser un (ou plusieurs) petit clap ğŸ˜‰
:::

> _â€œOn a pas besoin de NgRx dans notre projet, on fait la mÃªme chose avec des BehaviorSubject ou des Signals !â€_ <br/> _â€œNgRx est trop verbeux, il y a trop de fichiers !â€_ <br/> _â€œNgRx câ€™est bien mais uniquement pour les gros projets !â€_ <br/>

Ca vous parle Ã§a ? Moi oui. Câ€™est le discours que jâ€™entends depuis 5 ans que jâ€™utilise NgRx. Certains personnes peuvent Ãªtre rÃ©fractaire Ã  lâ€™idÃ©e dâ€™utiliser cet outil car il est parfois vu comme une usine Ã  gaz difficile Ã  utiliser pour peu de bÃ©nÃ©fice Ã  la fin.

Mais est-ce vrai ?

Est-ce que les derniÃ¨res versions dâ€™Angular avec les Signals peuvent rendre NgRx superflue ?
Est-ce que les derniÃ¨res versions de NgRx viennent suffisamment rÃ©duire la complexitÃ© de lâ€™outil pour justifier son utilisation ?

Dans cette article, nous allons voir si vous avez besoin de NgRx mais Ã©galement si vous avez intÃ©rÃªt Ã  lâ€™utiliser.

> Note : il existe dâ€™autres solutions tout aussi intÃ©ressantes que NgRx (Akita, Elf, NgXs, StateAdaptâ€¦) mais ici on va sâ€™intÃ©resser Ã  NgRx car câ€™est la plus souvent utilisÃ©e.

> Autre note : mÃªme si je fais un rÃ©capâ€™ dans lâ€™article, il est recommandÃ© de connaÃ®tre le principe de NgRx pour pleinement apprÃ©cier cette article (actions, reducer, effects, selectors). Je prÃ©vois un article et une formation sur le sujet !

---

Je dois bien avouer que quand on voit Ã§a :

```ts
@Injectable({ providedIn: "root" })
export class TodosService {
  readonly #http = inject(HttpClient);

  readonly todos = signal<Todo[]>([]);
  readonly error = signal<string | null>(null);
  readonly hasTodos = computed(() => this.todos().length > 0);

  loadTodos() {
    this.#http
      .get<Todo[]>("api/todos")
      .pipe(takeUntilDestroyed())
      .subscribe({
        next: (todos) => this.todos.set(todos),
        error: (error) => this.error.set(error.message),
      });
  }

  removeTodo(id: number) {
    this.todos.update((todos) => todos.filter((todo) => todo.id !== id));
  }
}
```

```
@Component({
  template: `
    <p *ngIf="service.error()">
      Error: {{ service.error() }}
    </p>

    <ul *ngIf="service.hasTodos()">
      <li *ngFor="let todo of service.todos()">
        {{todo.title}}
        <button (click)="service.removeTodo(todo.id)">remove</button>
      </li>
    </ul>
  `,
})
export class TodosComponent {
  readonly service = inject(TodosService);

  constructor() {
    this.service.loadTodos();
  }
}
```

On peut se demander pourquoi on sâ€™embÃªterait Ã  faire Ã§a :

```ts
export interface State {
  todos: Todo[];
  error: string | null;
}

export const initialState: State = {
  todos: [],
  error: null,
};

// actions
export const todosActions = createActionGroup({
  source: "Todos Page",
  events: {
    todosPageInitialized: emptyProps(),
    loadTodosSucceeded: props<{ todos: Todo[] }>(),
    loadTodosFailed: props<{ error: string }>(),
    removeTodoRequested: props<{ id: string }>(),
  },
});

// reducer et selectors
export const todosFeature = createFeature({
  name: "todos",
  reducer: createReducer(
    initialState,
    on(TodoActions.loadTodosSucceeded, (state, { todos }) => ({
      ...state,
      todos,
    })),
    on(TodoActions.loadTodosFailure, (state, { error }) => ({
      ...state,
      error,
    })),
    on(TodoActions.removeTodoRequested, (state, { todoId }) => ({
      ...state,
      todos: state.todos.filter((todo) => todo.id !== todoId),
    }))
  ),
  extraSelectors: ({ selectTodos }) => ({
    selectHasTodos: createSelector(selectTodos, (todos) => todos.length > 0),
  }),
});

// effects
export const loadTodos = createEffect(
  (actions$ = inject(Actions), http = inject(HttpClient)) =>
    actions$.pipe(
      ofType(todosActions.todosPageInitialized),
      switchMap(() =>
        http.get<Todo[]>("api/todos").pipe(
          map((todos) => todosActions.loadTodosSucceeded({ todos })),
          catchError((error) => of(todosActions.loadTodosFailed({ error })))
        )
      )
    ),
  { functional: true }
);

// facade
export function injectTodosStore() {
  const store = inject(Store);

  return {
    removeTodoRequested: (id: number) =>
      store.dispatch(todosActions.removeTodoRequested({ id })),
    todosPageInitialized: () =>
      store.dispatch(todosActions.todosPageInitialized()),
    todos: store.selectSignal(todosFeature.selectTodos),
    error: store.selectSignal(todosFeature.selectError),
    hasTodos: store.selectSignal(todosFeature.selectHasTodos),
  };
}
```

```ts
@Component({
  template: `
    <p *ngIf="todosStore.error()">Error: {{ todosStore.error() }}</p>

    <ul *ngIf="todosStore.hasTodos()">
      <li *ngFor="let todo of todosStore.todos()">
        {{ todo.title }}
        <button (click)="todosStore.removeTodoRequested(todo.id)">
          remove
        </button>
      </li>
    </ul>
  `,
})
export class TodosListComponent {
  readonly todosStore = injectTodosStore();

  constructor() {
    this.todosStore.todosPageInitialized();
  }
}
```

La version NgRx est clairement plus verbeuse :
ğŸ‘‰23 lignes de code sans NgRx
ğŸ‘‰54 lignes de code avec NgRx (en comptant lâ€™interface du state et la facade, sinon on est Ã  36)

Et le tout pour un rÃ©sultat fonctionnellement identique. Alors pourquoi sâ€™embÃªter Ã  utiliser NgRx ?

**RÃ©ponse : parce que lâ€™approche de NgRx propose des avantages qui rendront vos codebases plus maintenables.**

Jâ€™en parle plus longuement dans mon article â€œNgRx en 2023 : les bonnes pratiquesâ€.

> Vous vous demandez peut-Ãªtre ce quâ€™est cette syntaxe NgRx, notamment createActionGroup et createFeature ? Câ€™est la syntaxe moderne de NgRx ! Et oui, vous ne le saviez peut-Ãªtre pas mais lâ€™API moderne de NgRx est probablement trÃ¨s diffÃ©rente de ce que vous utilisez au quotidien. GrÃ¢ce Ã  elle on peut avoir des stores dâ€™un seul fichier ! <br /> Jâ€™en parle plus longuement dans mon article [â€œNgRx en 2023 : les bonnes pratiquesâ€](/articles/les-bonnes-pratiques-de-ngrx-en-2023/).

#### La diffÃ©rence fondamentale entre lâ€™approche de NgRx et lâ€™approche â€œclassiqueâ€

NgRx se repose sur le pattern Flux proposÃ© par Facebook et utilisÃ© maintenant par bons nombres de solutions de State Management. Ce pattern repose sur la gestion dâ€™un store qui contient un state, des actions, des reducers, des effects et des selectors.

VoilÃ  en quelques mots comment Ã§a fonctionne :

- A lâ€™Ã©tat initial, mon application Ã©coute toutes les actions en mÃªme temps
- Lorsquâ€™un Ã©vÃ¨nement survient dans un endroit de mon application (le clique sur le bouton â€œremove todoâ€, une requÃªte HTTP qui partâ€¦) alors on â€œdispatchâ€ (dÃ©clenche) une action qui dit â€œil vient de se passer cet Ã©vÃ¨nementâ€.
- Un ou plusieurs endroits (reducers et/ou effects) rÃ©agissent Ã  cette action en modifiant le state ou en dispatchant une nouvelle action
- Mon state est mis Ã  jour, je peux lâ€™utiliser dans mes composants et/ou services

Câ€™est exactement ce que je fais dans mon store NgRx plus haut :

```ts
// cette action dÃ©crit l'Ã©vÃ¨nement qui vient de se passer
constructor() {
  this.todosStore.todosPageInitialized();
}

// l'effect dans todos.store.ts
export const loadTodos = createEffect(
  (
    actions$ = inject(Actions), // ğŸ‘ˆ le bus d'actions de mon app
    http = inject(HttpClient)
  ) =>
    actions$.pipe(
      ofType(todosActions.todosPageInitialized), // ğŸ‘ˆ j'Ã©coutel'action qui m'intÃ©resse
      switchMap(() =>
        http.get<Todo[]>('api/todos').pipe(
          // ğŸ‘‡ je dispatch l'action correspondante selon le success ou fail
          map((todos) => todosActions.loadTodosSucceeded({ todos })),
          catchError((error) => of(todosActions.loadTodosFailed({ error })))
        )
      )
    ),
  { functional: true }
);

// le reducer dans todos.store.ts
export const todosFeature = createFeature({
  name: 'todos',
  reducer: createReducer(
    initialState,
    // ğŸ‘‡je modifie mon state ici
    on(TodoActions.loadTodosSucceeded, (state, { todos }) => ({ ...state, todos })),
    on(TodoActions.loadTodosFailed, (state, { error }) => ({ ...state, error })),
  )
});
```

Tandis que sur lâ€™approche classique oÃ¹ jâ€™exÃ©cute une fonction, on passe par moins dâ€™Ã©tapes :

```ts
// le composant exÃ©cute la fonction dans le constructor
constructor() {
  this.todosService.loadTodos();
}

// dans todos.service.ts
readonly todos = signal<Todo[]>([]);
readonly error = signal<string | null>(null);

loadTodos() {
  this.#http
    .get<Todo[]>('api/todos')
    .pipe(
      takeUntilDestroyed()
    )
     // ğŸ‘‡je modifie mes signals ici
    .subscribe({
       next: (todos) => this.todos.set(todos),
       error: (error) => this.error.set(error.message),
     });
}
```

En terme de lisibilitÃ© une approche classique gagne Ã  plat de couture. Et vous commencez Ã  me connaÃ®tre si vous me lisez souvent, je suis un amoureux de la simplicitÃ© et de la DX agrÃ©able.

Mais il y a dÃ©savantage clair Ã  lâ€™approche classique : si jâ€™ai besoin de rÃ©agir Ã  loadTodos Ã  un autre endroit de mon application alors les ennuis commencent.

Je mâ€™explique.

Admettons que mon PO me demande une Ã©volution. DÃ©sormais quand les todos sont chargÃ©s je dois dÃ©clencher 3 autres requÃªtes HTTP et/ou changer une donnÃ©e dâ€™un autre state de mon app.

Comment faire Ã©voluer mon code en ce sens ?

#### Sans NgRx

Est-ce la fonction loadTodos de mon service qui doit porter cette logique ?

```ts
// le composant exÃ©cute la fonction dans le constructor
constructor() {
  this.todosService.loadTodos();
}

// dans todos.service.ts
// j'injecte mes autres services ğŸ‘‡
readonly #service1 = inject(Service1);
readonly #service2 = inject(Service2);
readonly #service3 = inject(Service3);

readonly todos = signal<Todo[]>([]);
readonly error = signal<string | null>(null);

loadTodos() {
  this.#http
    .get<Todo[]>('api/todos')
    .pipe(
      takeUntilDestroyed()
    )
    .subscribe({
       next: (todos) => {
        this.todos.set(todos);
        // j'appelle le load des autres services
        this.#service1.load();
        this.#service2.load();
        this.#service3.load();
       },
       error: (error) => this.error.set(error.message),
     });
}
```

Mais dans ce cas-lÃ  ma separation of concerns est complÃ¨tement brisÃ©e, mon loadTodos fait bien plus que ce qui prÃ©tend faire, mon code devient complÃ¨tement impÃ©ratif et plus lourd Ã  tester car je dois mock plusieurs services.

Alors si ce nâ€™est pas le service qui doit porter cette logique, câ€™est peut-Ãªtre le composant ?

```ts
// dans todos.component.ts
readonly #service1 = inject(Service1);
readonly #service2 = inject(Service2);
readonly #service3 = inject(Service3);

constructor() {
  this.todosService.loadTodos()
    .subscribe({
       next: (todos) => {
        this.#service1.load();
        this.#service2.load();
        this.#service3.load();
       },
     })
}

// dans todos.service.ts
// j'ai du modifier mon ancien code pour qu'il return l'observable
// et qu'il set les 'signals' dans l'opÃ©rateur 'tap'
loadTodos() {
  return this.#http
    .get<Todo[]>('api/todos')
    .pipe(
      takeUntilDestroyed(),
      tap({
       next: (todos) => this.todos.set(todos),
       error: (error) => this.error.set(error.message),
     })
    )
}
```

Ce nâ€™est pas spÃ©cialement mieux. Le composant Ã  maintenant trop de logique impÃ©rative, la separation of concerns est Ã©galement brisÃ©e.

Bref, dans les deux cas on sent venir le spaghetti code et faire des TUs devient complexe. Mais Ã©galement : on a du replonger dans les features quâ€™on avait dÃ©jÃ  codÃ© pour les modifier.

Mais avec NgRx ?

#### Avec NgRx

```ts
// le composant ET l'effect restent inchangÃ©s !
// AUCUNE modification n'est nÃ©cessaire sur l'ancien code !

// Dans mes autres stores j'Ã©coute sur le loadTodosSucceeded que
// j'avais dispatchÃ© au retour API dans todos.store.ts
export const doSomething = createEffect(
  (actions$ = inject(Actions)) =>
    actions$.pipe(
      // ğŸ‘‡ ici
      ofType(TodosActions.loadTodosSucceeded),
      ...
    )
  ,
  { functional: true }
);


export const someStoreFeature = createFeature({
  name: 'someStore',
  reducer: createReducer(
    initialState,
    // ğŸ‘‡ et lÃ 
    on(TodosActions.loadTodosSucceeded, (state) => ...),
  )
});
```

Vous voyez ce que je viens de faire ? Avec NgRx les autres stores de mon application Ã©coutent Ã©galement les actions des stores qui les intÃ©ressent !

Et Ã§a change TOUT !

Les paradigmes sont complÃ¨tements diffÃ©rents, avec lâ€™approche classique, quâ€™on appelle â€œCommand Patternâ€, jâ€™appelle une fonction qui appelle une fonction qui appelle une fonction tandis quâ€™avec NgRx je dispatch une action qui peut Ãªtre Ã©coutÃ©e par tout le monde et rÃ©agir de maniÃ¨re diffÃ©rente selon qui lâ€™Ã©coute !

Câ€™est une approche impÃ©rative versus une approche dÃ©clarative et rÃ©active.

- Avec une approche classique, vous donnez des ordres : â€œcharge les todos, puis charge cela, puis fais ceci !â€ et dans chaque â€œceci ou celaâ€ des ordres subsÃ©quents peuvent Ãªtre Ã©galement donnÃ©s.
- Avec NgRx (Flux Pattern), quand un Ã©vÃ¨nement survient (ex: â€œle composant vient de se chargerâ€) vous le poussez dans un flux dâ€™actions et ceux qui Ã©coutent dessus peuvent rÃ©agir comme bon leur semble.

En rÃ©sumÃ©, avec le Flux Pattern, nâ€™importe quel endroit de lâ€™application peut rÃ©agir Ã  cet Ã©vÃ¨nement alors que le Command Pattern exige que lâ€™on exÃ©cute explicitement les fonctions.

On peut mÃªme faire ce genre de choses avec NgRx :

```ts
export const someEffect = createEffect(
  (actions$ = inject(Actions)) =>
    $actions.pipe(
      ofType(
        someAction1,
        someAction2,
        someAction3,
       ),
      ...
    )
);

export const someStoreFeature = createFeature({
  name: 'someStore',
  reducer: createReducer(
    initialState,
    on(
      someAction1,
      someAction2,
      someAction3,
      (state) => ...
    ),
  )
});
```

En gros, un effect ou un reducer peuvent Ã©couter sur plusieurs actions. Dans une approche classique le rÃ©sultat serait beaucoup moins agrÃ©able Ã  gÃ©rer car on devrait :

- Replonger dans lâ€™ancienne feature pour ajouter lâ€™exÃ©cution de fonctions dâ€™autres services
- Adapter le TU en consÃ©quence
- Serrer les fesses pour espÃ©rer ne pas avoir introduit de rÃ©gressions

Et lÃ  mon exemple est simple, une simple todos list avec une feature de load et de remove. Imaginez une application avec des dizaines de pages, des centaines de features et des dizaines de personnes qui lâ€™ont maintenu pendant des annÃ©es. Lâ€™effet se multiplierait de plus en plus ! ğŸ¤¯

Avec NgRx correctement appliquÃ©, on minimise cet impact car chaque partie logique de lâ€™app est isolÃ©. On a pas de relation direct entre les features, on a des Ã©vÃ¨nements et des rÃ©actions.

Nos composants ne servent que la UI, ils vont uniquement dispatch des actions qui dÃ©crivent les Ã©vÃ¨nements, par exemple pageInitialized, et des morceaux de codes vont catch cet Ã©vÃ¨nement pour faire des calls HTTP ou autres.

Voyez-vous maintenant la puissance du Flux Pattern sur lequel se base NgRx et pourquoi cela peut rendre vos applications plus maintenable ?

Et ce nâ€™est pas tout ! Lâ€™Ã©cosystÃ¨me NgRx possÃ¨de beaucoup de fonctionnalitÃ©s lÃ  pour vous aider.

#### Lâ€™Ã©cosystÃ¨me NgRx

NgRx est bien plus quâ€™une librairie, câ€™est un Ã©cosystÃ¨me disposant dâ€™une multitude dâ€˜extensions pour vous aider dans vos besoins quotidiens. Par exemple effects est lâ€™une de ces extensions. Mais il en existe dâ€™autres.

##### Router-Store

On y trouve â€œ@ngrx/router-storeâ€ qui nous renvoie un tas de selectors trÃ¨s utile :

```ts
import { getRouterSelectors, RouterReducerState } from "@ngrx/router-store";

export const {
  selectCurrentRoute, // select the current route
  selectFragment, // select the current route fragment
  selectQueryParams, // select the current route query params
  selectQueryParam, // factory function to select a query param
  selectRouteParams, // select the current route params
  selectRouteParam, // factory function to select a route param
  selectRouteData, // select the current route data
  selectRouteDataParam, // factory function to select a route data param
  selectUrl, // select the current url
  selectTitle, // select the title if available
} = getRouterSelectors();
```

Câ€™est trÃ¨s utile pour faire de la composition de selectors ou pour utiliser dans vos effects.

##### Developer Tools

Câ€™est le gros plus de NgRx/store ! On a accÃ¨s au state global de notre application dans le Redux Devtools Extension. Ainsi, on peut voir Ã  tout moment chacun de nos states, lâ€™historique des actions dispatchÃ©es avec leurs payload et mÃªme rejouer ces derniÃ¨res !

Câ€™est vraiment un must-have et câ€™est une merveille pour le debugging. ğŸ¤©

[Plus dâ€™infos ici.](https://ngrx.io/guide/store-devtools)

##### Component Store

Voici une super extension que jâ€™ai beaucoup utilisÃ©.
Elle vous permet de gÃ©rer un store local (pour votre composant) sans les actions, reducers etc mais tout en gardant de bonnes pratiques et performances.

On peut voir lâ€™Ã©quivalent de notre applications todos sous Component Store :

```ts
export interface State {
  todos: Todo[];
  error: string | null;
}

export const initialState: State = {
  todos: [],
  error: null,
};

@Injectable()
export class TodosListStore extends ComponentStore<State> {
  readonly #todosService = inject(TodosService);

  readonly todos = this.selectSignal(state => state.todos);
  readonly error = this.selectSignal(state => state.error);
  readonly hasTodos= this.selectSignal(state => state.todos > 0);

  constructor() {
    super(initialState);
  }

  readonly loadTodos= this.effect<void>(
     (trigger$) => trigger$.pipe(
      switchMap(() =>
        this.#todosService.loadTodos().pipe(
          tapResponse({
            next: (todos) => this.patchState({ todos },
            error: (error: HttpErrorResponse) => this.patchState({ error},
          })
        )
      )
    )
  );

  removeTodo(id: number) {
    this.todos.setState(state => ({...state, todos: todos.filter(todo => todo.id !== id)}))
  }
}
```

Câ€™est une bonne alternative si vous voulez une approche simple du State Management. Je vous conseille cette extension plutÃ´t que dâ€™implÃ©menter une solution de State Management faite maison.

En revanche il est Ã  noter que :

- Le Developer Tool ne fonctionne pas avec Component Store
- Cela reste du Command Pattern

##### Dâ€™autres bonnes raisons dâ€™utiliser NgRx

Si vous utilisez correctement NgRx, vous pourrez Ãªtre certains que mÃªme une nouvelle personne qui rejoint lâ€™Ã©quipe prendra en mains rapidement votre application.

Aussi, NgRx est constamment mis Ã  jour et ils travaillent avec la team Angular pour toujours avancer dans la mÃªme direction. Câ€™est pour cela que NgRx est trÃ¨s performants et les features trÃ¨s adaptÃ©s au framework Angular.

Vous avez peut-Ãªtre envie de crÃ©er votre propre solution basÃ©e sur les principes de Redux [comme certains le font](https://www.youtube.com/watch?v=R4Ff2bPiWh4&ab_channel=JoshuaMorony) et il serait intÃ©ressant de le faire car cela vous aidera Ã  comprendre parfaitement les avantages de cette approche. Mais ayez en tÃªte quâ€™en faisant cela, il y a de fortes chances que vous ne fassiez que recrÃ©er la roue (en probablement moins bien). Vous devrez la maintenir, la faire Ã©voluer, la documenterâ€¦ Bref câ€™est un boulot Ã  pleins temps ! Et croyez moi, des projets qui utilisent correctement NgRx Ã§a ne court pas les rues, alors leurs propres solutions faites maisonâ€¦ ğŸ˜¬

Sachez Ã©galement que connaÃ®tre NgRx aide trÃ¨s largement Ã  lâ€™embauche car beaucoup de projets lâ€™utilisent. MaÃ®triser cette outil et lâ€™indiquer sur son CV est un gros plus.

Enfin, des travaux sont en cours pour proposer un ngrx/signals. Vous pouvez dÃ©couvrir [la doc ici](https://github.com/markostanimirovic/ngrx-signal-store-playground#ngrx-signals).
Cela semble trÃ¨s prometteur, le boilerplate est encore plus rÃ©duit que pour component-store ! Jâ€™ai lâ€™impression quâ€™on reste sur du Command Pattern mais jâ€™ai hÃ¢te de voir Ã§a. Ce nâ€™est franchement pas impossible quâ€™Ã  terme cela devienne ma solution par dÃ©faut. A voir quand Ã§a sortira ! Je ferai un article dessus of course !

#### Des raisons de ne pas utiliser NgRx

Si votre Ã©quipe nâ€™arrive pas Ã  prendre NgRx/store en mains, alors ne lâ€™utilisez pas. AprÃ¨s tout le but est dâ€™Ãªtre productif, et NgRx/store Ã  un coÃ»t non nÃ©gligeable en terme dâ€™apprentissage.

Donc si vous Ãªtes dans un rush, que vous avez des deadline serrÃ©es et que le rapport risque/coÃ»t nâ€™est pas bon, utilisez plutÃ´t NgRx/component-store voire les Signals en â€œvanillaâ€.

Ce nâ€™est Ã©videmment pas non plus garanti que votre Ã©quipe fasse du travail propre avec component-store ou les Signals, mais au moins il nâ€™y a pas tout une mÃ©canique Ã  apprendre, câ€™est dÃ©jÃ  Ã§a !

Mais câ€™est indÃ©niable : NgRx est verbeux et je comprends que Ã§a puisse en rebuter certains. Cependant Ã  mon sens cette verbositÃ© vaut le coup sur le long terme car vous aurez une application parfaitement rÃ©active, dÃ©clarative et qui permet une meilleure separation of concerns.

#### Conclusion

A la question â€œavez-vous besoin de NgRxâ€ je rÃ©ponds : non, vous pouvez faire des applications qualitatives sans.

Mais Ã  la question â€œavez-vous intÃ©rÃªt Ã  utiliser NgRxâ€, je rÃ©ponds : OUI ! Votre application nâ€™en sera que plus qualitative, maintenable et suivra de meilleures pratiques qui se reposent sur la programmation dÃ©claratives et rÃ©actives !
