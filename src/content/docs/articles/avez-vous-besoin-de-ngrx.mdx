---
title: Avez-vous besoin de NgRx ?
description: Avez-vous besoin de NgRx ?
---

:::note
Cette article existe √©galement sur [Medium](https://medium.com/@kevin.tale/avez-vous-besoin-de-ngrx-3a09a02cea28). <br />
S'il vous a plu, n'h√©sitez pas √† me laisser un (ou plusieurs) petit clap üòâ
:::

> _‚ÄúOn a pas besoin de NgRx dans notre projet, on fait la m√™me chose avec des BehaviorSubject ou des Signals !‚Äù_ <br/> _‚ÄúNgRx est trop verbeux, il y a trop de fichiers !‚Äù_ <br/> _‚ÄúNgRx c‚Äôest bien mais uniquement pour les gros projets !‚Äù_ <br/>

Ca vous parle √ßa ? Moi oui. C‚Äôest le discours que j‚Äôentends depuis 5 ans que j‚Äôutilise NgRx. Certains personnes peuvent √™tre r√©fractaire √† l‚Äôid√©e d‚Äôutiliser cet outil car il est parfois vu comme une usine √† gaz difficile √† utiliser pour peu de b√©n√©fice √† la fin.

Mais est-ce vrai ?

Est-ce que les derni√®res versions d‚ÄôAngular avec les Signals peuvent rendre NgRx superflue ?
Est-ce que les derni√®res versions de NgRx viennent suffisamment r√©duire la complexit√© de l‚Äôoutil pour justifier son utilisation ?

Dans cette article, nous allons voir si vous avez **besoin** de NgRx mais √©galement si vous avez **int√©r√™t** √† l‚Äôutiliser.

> Note : il existe d‚Äôautres solutions tout aussi int√©ressantes que NgRx (Akita, Elf, NgXs, StateAdapt‚Ä¶) mais ici on va s‚Äôint√©resser √† NgRx car c‚Äôest la plus souvent utilis√©e.

> Autre note : m√™me si je fais un r√©cap‚Äô dans l‚Äôarticle, il est recommand√© de conna√Ætre le principe de NgRx pour pleinement appr√©cier cette article (actions, reducer, effects, selectors). Je pr√©vois un article et une formation sur le sujet !

---

Je dois bien avouer que quand on voit √ßa :

```ts
@Injectable({ providedIn: "root" })
export class TodosService {
  readonly #http = inject(HttpClient);

  readonly todos = signal<Todo[]>([]);
  readonly error = signal<string | null>(null);
  readonly hasTodos = computed(() => this.todos().length > 0);

  loadTodos() {
    this.#http
      .get<Todo[]>("api/todos")
      .pipe(takeUntilDestroyed())
      .subscribe({
        next: (todos) => this.todos.set(todos),
        error: (error) => this.error.set(error.message),
      });
  }

  removeTodo(id: number) {
    this.todos.update((todos) => todos.filter((todo) => todo.id !== id));
  }
}
```

```ts
@Component({
  template: `
    <p *ngIf="service.error()">
      Error: {{ service.error() }}
    </p>

    <ul *ngIf="service.hasTodos()">
      <li *ngFor="let todo of service.todos()">
        {{todo.title}}
        <button (click)="service.removeTodo(todo.id)">remove</button>
      </li>
    </ul>
  `,
})
export class TodosComponent {
  readonly service = inject(TodosService);

  constructor() {
    this.service.loadTodos();
  }
}
```

On peut se demander pourquoi on s‚Äôemb√™terait √† faire √ßa :

```ts
export interface State {
  todos: Todo[];
  error: string | null;
}

export const initialState: State = {
  todos: [],
  error: null,
};

// actions
export const todosActions = createActionGroup({
  source: "Todos Page",
  events: {
    todosPageInitialized: emptyProps(),
    loadTodosSucceeded: props<{ todos: Todo[] }>(),
    loadTodosFailed: props<{ error: string }>(),
    removeTodoRequested: props<{ id: string }>(),
  },
});

// reducer et selectors
export const todosFeature = createFeature({
  name: "todos",
  reducer: createReducer(
    initialState,
    on(TodoActions.loadTodosSucceeded, (state, { todos }) => ({
      ...state,
      todos,
    })),
    on(TodoActions.loadTodosFailure, (state, { error }) => ({
      ...state,
      error,
    })),
    on(TodoActions.removeTodoRequested, (state, { todoId }) => ({
      ...state,
      todos: state.todos.filter((todo) => todo.id !== todoId),
    }))
  ),
  extraSelectors: ({ selectTodos }) => ({
    selectHasTodos: createSelector(selectTodos, (todos) => todos.length > 0),
  }),
});

// effects
export const loadTodos = createEffect(
  (actions$ = inject(Actions), http = inject(HttpClient)) =>
    actions$.pipe(
      ofType(todosActions.todosPageInitialized),
      switchMap(() =>
        http.get<Todo[]>("api/todos").pipe(
          map((todos) => todosActions.loadTodosSucceeded({ todos })),
          catchError((error) => of(todosActions.loadTodosFailed({ error })))
        )
      )
    ),
  { functional: true }
);

// facade
export function injectTodosStore() {
  const store = inject(Store);

  return {
    removeTodoRequested: (id: number) =>
      store.dispatch(todosActions.removeTodoRequested({ id })),
    todosPageInitialized: () =>
      store.dispatch(todosActions.todosPageInitialized()),
    todos: store.selectSignal(todosFeature.selectTodos),
    error: store.selectSignal(todosFeature.selectError),
    hasTodos: store.selectSignal(todosFeature.selectHasTodos),
  };
}
```

```ts
@Component({
  template: `
    <p *ngIf="todosStore.error()">Error: {{ todosStore.error() }}</p>

    <ul *ngIf="todosStore.hasTodos()">
      <li *ngFor="let todo of todosStore.todos()">
        {{ todo.title }}
        <button (click)="todosStore.removeTodoRequested(todo.id)">
          remove
        </button>
      </li>
    </ul>
  `,
})
export class TodosListComponent {
  readonly todosStore = injectTodosStore();

  constructor() {
    this.todosStore.todosPageInitialized();
  }
}
```

La version NgRx est clairement plus verbeuse :
- 23 lignes de code sans NgRx
- 54 lignes de code avec NgRx (en comptant l‚Äôinterface du state et la facade, sinon on est √† 36)

Et le tout pour un r√©sultat fonctionnellement identique. Alors pourquoi s‚Äôemb√™ter √† utiliser NgRx ?

**R√©ponse : parce que l‚Äôapproche de NgRx propose des avantages qui rendront vos codebases plus maintenables.**

> Vous vous demandez peut-√™tre ce qu‚Äôest cette syntaxe NgRx, notamment `createActionGroup` et `createFeature` ? C‚Äôest la syntaxe moderne de NgRx ! <br /> J‚Äôen parle plus longuement dans mon article [‚ÄúNgRx en 2023 : les bonnes pratiques‚Äù](/articles/les-bonnes-pratiques-de-ngrx-en-2023/).

### La diff√©rence fondamentale entre l‚Äôapproche de NgRx et l‚Äôapproche ‚Äúclassique‚Äù

NgRx se repose sur le pattern Flux propos√© par Facebook et utilis√© maintenant par bons nombres de solutions de State Management. Ce pattern repose sur la gestion d‚Äôun store qui contient un state, des actions, des reducers, des effects et des selectors.

Voil√† en quelques mots comment √ßa fonctionne :

- A l‚Äô√©tat initial, mon application √©coute toutes les actions en m√™me temps
- Lorsqu‚Äôun √©v√®nement survient dans un endroit de mon application (le clique sur le bouton ‚Äúremove todo‚Äù, une requ√™te HTTP qui part‚Ä¶) alors on ‚Äúdispatch‚Äù (d√©clenche) une action qui dit ‚Äúil vient de se passer cet √©v√®nement‚Äù.
- **Un ou plusieurs endroits (reducers et/ou effects) r√©agissent √† cette action** en modifiant le state ou en dispatchant une nouvelle action
- Mon state est mis √† jour, je peux l‚Äôutiliser dans mes composants et/ou services

C‚Äôest exactement ce que je fais dans mon store NgRx plus haut :

```ts
// cette action d√©crit l'√©v√®nement qui vient de se passer
constructor() {
  this.todosStore.todosPageInitialized();
}

// l'effect dans todos.store.ts
export const loadTodos = createEffect(
  (
    actions$ = inject(Actions), // üëà le bus d'actions de mon app
    http = inject(HttpClient)
  ) =>
    actions$.pipe(
      ofType(todosActions.todosPageInitialized), // üëà j'√©coutel'action qui m'int√©resse
      switchMap(() =>
        http.get<Todo[]>('api/todos').pipe(
          // üëá je dispatch l'action correspondante selon le success ou fail
          map((todos) => todosActions.loadTodosSucceeded({ todos })),
          catchError((error) => of(todosActions.loadTodosFailed({ error })))
        )
      )
    ),
  { functional: true }
);

// le reducer dans todos.store.ts
export const todosFeature = createFeature({
  name: 'todos',
  reducer: createReducer(
    initialState,
    // üëáje modifie mon state ici
    on(TodoActions.loadTodosSucceeded, (state, { todos }) => ({ ...state, todos })),
    on(TodoActions.loadTodosFailed, (state, { error }) => ({ ...state, error })),
  )
});
```

Tandis que sur l‚Äôapproche classique o√π j‚Äôex√©cute une fonction, on passe par moins d‚Äô√©tapes :

```ts
// le composant ex√©cute la fonction dans le constructor
constructor() {
  this.todosService.loadTodos();
}

// dans todos.service.ts
readonly todos = signal<Todo[]>([]);
readonly error = signal<string | null>(null);

loadTodos() {
  this.#http
    .get<Todo[]>('api/todos')
    .pipe(
      takeUntilDestroyed()
    )
     // üëáje modifie mes signals ici
    .subscribe({
       next: (todos) => this.todos.set(todos),
       error: (error) => this.error.set(error.message),
     });
}
```

En terme de lisibilit√© une approche classique gagne √† plat de couture. Et vous commencez √† me conna√Ætre si vous me lisez souvent, je suis un amoureux de la simplicit√© et de la DX agr√©able.

Mais il y a d√©savantage clair √† l‚Äôapproche classique : si j‚Äôai besoin de r√©agir √† loadTodos √† un autre endroit de mon application alors les ennuis commencent.

Je m‚Äôexplique.

Admettons que mon PO me demande une √©volution. D√©sormais quand les todos sont charg√©s je dois d√©clencher 3 autres requ√™tes HTTP et/ou changer une donn√©e d‚Äôun autre state de mon app.

Comment faire √©voluer mon code en ce sens ?

### Sans NgRx

Est-ce la fonction `loadTodos` de mon service qui doit porter cette logique ?

```ts
// le composant ex√©cute la fonction dans le constructor
constructor() {
  this.todosService.loadTodos();
}

// dans todos.service.ts
// j'injecte mes autres services üëá
readonly #service1 = inject(Service1);
readonly #service2 = inject(Service2);
readonly #service3 = inject(Service3);

readonly todos = signal<Todo[]>([]);
readonly error = signal<string | null>(null);

loadTodos() {
  this.#http
    .get<Todo[]>('api/todos')
    .pipe(
      takeUntilDestroyed()
    )
    .subscribe({
       next: (todos) => {
        this.todos.set(todos);
        // j'appelle le load des autres services
        this.#service1.load();
        this.#service2.load();
        this.#service3.load();
       },
       error: (error) => this.error.set(error.message),
     });
}
```

Mais dans ce cas-l√† ma separation of concerns est compl√®tement bris√©e, mon `loadTodos` fait bien plus que ce qui pr√©tend faire, mon code devient compl√®tement imp√©ratif et plus lourd √† tester car je dois mock plusieurs services.

Alors si ce n‚Äôest pas le service qui doit porter cette logique, c‚Äôest peut-√™tre le composant ?

```ts
// dans todos.component.ts
readonly #service1 = inject(Service1);
readonly #service2 = inject(Service2);
readonly #service3 = inject(Service3);

constructor() {
  this.todosService.loadTodos()
    .subscribe({
       next: (todos) => {
        this.#service1.load();
        this.#service2.load();
        this.#service3.load();
       },
     })
}

// dans todos.service.ts
// j'ai du modifier mon ancien code pour qu'il return l'observable
// et qu'il set les 'signals' dans l'op√©rateur 'tap'
loadTodos() {
  return this.#http
    .get<Todo[]>('api/todos')
    .pipe(
      takeUntilDestroyed(),
      tap({
       next: (todos) => this.todos.set(todos),
       error: (error) => this.error.set(error.message),
     })
    )
}
```

Ce n‚Äôest pas sp√©cialement mieux. Le composant √† maintenant trop de logique imp√©rative, la separation of concerns est √©galement bris√©e.

Bref, dans les deux cas on sent venir le spaghetti code et faire des TUs devient complexe. Mais √©galement : **on a du replonger dans les features qu‚Äôon avait d√©j√† cod√© pour les modifier.**

Mais avec NgRx ?

### Avec NgRx

```ts
// le composant ET l'effect restent inchang√©s !
// AUCUNE modification n'est n√©cessaire sur l'ancien code !

// Dans mes autres stores j'√©coute sur le loadTodosSucceeded que
// j'avais dispatch√© au retour API dans todos.store.ts
export const doSomething = createEffect(
  (actions$ = inject(Actions)) =>
    actions$.pipe(
      // üëá ici
      ofType(TodosActions.loadTodosSucceeded),
      ...
    )
  ,
  { functional: true }
);


export const someStoreFeature = createFeature({
  name: 'someStore',
  reducer: createReducer(
    initialState,
    // üëá et l√†
    on(TodosActions.loadTodosSucceeded, (state) => ...),
  )
});
```

Vous voyez ce que je viens de faire ? Avec NgRx les autres stores de mon application √©coutent √©galement les actions des stores qui les int√©ressent !

Et √ßa change **TOUT** !

Les paradigmes sont compl√®tements diff√©rents, avec l‚Äôapproche classique, qu‚Äôon appelle **‚ÄúCommand Pattern‚Äù**, j‚Äôappelle une fonction qui appelle une fonction qui appelle une fonction tandis qu‚Äôavec NgRx je dispatch une action qui peut √™tre √©cout√©e par tout le monde et r√©agir de mani√®re diff√©rente selon qui l‚Äô√©coute !

**C‚Äôest une approche imp√©rative versus une approche d√©clarative et r√©active.**

- Avec une approche classique, vous donnez des ordres : ‚Äúcharge les todos, puis charge cela, puis fais ceci !‚Äù et dans chaque ‚Äúceci ou cela‚Äù des ordres subs√©quents peuvent √™tre √©galement donn√©s.
- Avec NgRx (Flux Pattern), quand un √©v√®nement survient (ex: ‚Äúle composant vient de se charger‚Äù) vous le poussez dans un flux d‚Äôactions et ceux qui √©coutent dessus peuvent r√©agir comme bon leur semble.

En r√©sum√©, avec le Flux Pattern, n‚Äôimporte quel endroit de l‚Äôapplication peut r√©agir √† cet √©v√®nement alors que le Command Pattern exige que l‚Äôon ex√©cute explicitement les fonctions.

On peut m√™me faire ce genre de choses avec NgRx :

```ts
export const someEffect = createEffect(
  (actions$ = inject(Actions)) =>
    $actions.pipe(
      ofType(
        someAction1,
        someAction2,
        someAction3,
       ),
      ...
    )
);

export const someStoreFeature = createFeature({
  name: 'someStore',
  reducer: createReducer(
    initialState,
    on(
      someAction1,
      someAction2,
      someAction3,
      (state) => ...
    ),
  )
});
```

En gros, un effect ou un reducer peuvent √©couter sur plusieurs actions. Dans une approche classique le r√©sultat serait beaucoup moins agr√©able √† g√©rer car on devrait :

- Replonger dans l‚Äôancienne feature pour ajouter l‚Äôex√©cution de fonctions d‚Äôautres services
- Adapter le TU en cons√©quence
- Serrer les fesses pour esp√©rer ne pas avoir introduit de r√©gressions

Et l√† mon exemple est simple, une simple todos list avec une feature de load et de remove. Imaginez une application avec des dizaines de pages, des centaines de features et des dizaines de personnes qui l‚Äôont maintenu pendant des ann√©es. L‚Äôeffet se multiplierait de plus en plus ! ü§Ø

Avec NgRx **correctement appliqu√©**, on minimise cet impact car chaque partie logique de l‚Äôapp est isol√©. On a pas de relation direct entre les features, on a des √©v√®nements et des r√©actions.

Nos composants ne servent que la UI, ils vont uniquement dispatch des actions qui d√©crivent les √©v√®nements, par exemple pageInitialized, et des morceaux de codes vont catch cet √©v√®nement pour faire des calls HTTP ou autres.

Voyez-vous maintenant la puissance du Flux Pattern sur lequel se base NgRx et pourquoi cela peut rendre vos applications plus maintenable ?

Et ce n‚Äôest pas tout ! L‚Äô√©cosyst√®me NgRx poss√®de beaucoup de fonctionnalit√©s l√† pour vous aider.

### L‚Äô√©cosyst√®me NgRx

NgRx est bien plus qu‚Äôune librairie, c‚Äôest un √©cosyst√®me disposant d‚Äôune multitude d‚Äòextensions pour vous aider dans vos besoins quotidiens. Par exemple `effects` est l‚Äôune de ces extensions. Mais il en existe d‚Äôautres.

#### Router-Store

On y trouve ‚Äú@ngrx/router-store‚Äù qui nous renvoie un tas de selectors tr√®s utile :

```ts
import { getRouterSelectors, RouterReducerState } from "@ngrx/router-store";

export const {
  selectCurrentRoute, // select the current route
  selectFragment, // select the current route fragment
  selectQueryParams, // select the current route query params
  selectQueryParam, // factory function to select a query param
  selectRouteParams, // select the current route params
  selectRouteParam, // factory function to select a route param
  selectRouteData, // select the current route data
  selectRouteDataParam, // factory function to select a route data param
  selectUrl, // select the current url
  selectTitle, // select the title if available
} = getRouterSelectors();
```

C‚Äôest tr√®s utile pour faire de la composition de selectors ou pour utiliser dans vos effects.

#### Developer Tools

C‚Äôest le gros plus de NgRx/store ! On a acc√®s au state global de notre application dans le Redux Devtools Extension. Ainsi, on peut voir √† tout moment chacun de nos states, l‚Äôhistorique des actions dispatch√©es avec leurs payload et m√™me rejouer ces derni√®res !

C‚Äôest vraiment un must-have et c‚Äôest une merveille pour le debugging. ü§©

[Plus d‚Äôinfos ici.](https://ngrx.io/guide/store-devtools)

#### Component Store

Voici une super extension que j‚Äôai beaucoup utilis√©.
Elle vous permet de g√©rer un store local (pour votre composant) sans les actions, reducers etc mais tout en gardant de bonnes pratiques et performances.

On peut voir l‚Äô√©quivalent de notre applications todos sous Component Store :

```ts
export interface State {
  todos: Todo[];
  error: string | null;
}

export const initialState: State = {
  todos: [],
  error: null,
};

@Injectable()
export class TodosListStore extends ComponentStore<State> {
  readonly #todosService = inject(TodosService);

  readonly todos = this.selectSignal(state => state.todos);
  readonly error = this.selectSignal(state => state.error);
  readonly hasTodos= this.selectSignal(state => state.todos > 0);

  constructor() {
    super(initialState);
  }

  readonly loadTodos= this.effect<void>(
     (trigger$) => trigger$.pipe(
      switchMap(() =>
        this.#todosService.loadTodos().pipe(
          tapResponse({
            next: (todos) => this.patchState({ todos },
            error: (error: HttpErrorResponse) => this.patchState({ error},
          })
        )
      )
    )
  );

  removeTodo(id: number) {
    this.todos.setState(state => ({...state, todos: todos.filter(todo => todo.id !== id)}))
  }
}
```

C‚Äôest une bonne alternative si vous voulez une approche simple du State Management. Je vous conseille cette extension plut√¥t que d‚Äôimpl√©menter une solution de State Management faite maison.

En revanche il est √† noter que :

- Le Developer Tool ne fonctionne pas avec Component Store
- Cela reste du Command Pattern

### D‚Äôautres bonnes raisons d‚Äôutiliser NgRx

Si vous utilisez correctement NgRx, vous pourrez √™tre certains que m√™me une nouvelle personne qui rejoint l‚Äô√©quipe prendra en mains rapidement votre application.

Aussi, NgRx est constamment mis √† jour et ils travaillent avec la team Angular pour toujours avancer dans la m√™me direction. C‚Äôest pour cela que NgRx est tr√®s performants et les features tr√®s adapt√©s au framework Angular.

Vous avez peut-√™tre envie de cr√©er votre propre solution bas√©e sur les principes de Redux [comme certains le font](https://www.youtube.com/watch?v=R4Ff2bPiWh4&ab_channel=JoshuaMorony) et il serait int√©ressant de le faire car cela vous aidera √† comprendre parfaitement les avantages de cette approche. Mais ayez en t√™te qu‚Äôen faisant cela, il y a de fortes chances que vous ne fassiez que recr√©er la roue (en probablement moins bien). Vous devrez la maintenir, la faire √©voluer, la documenter‚Ä¶ Bref c‚Äôest un boulot √† pleins temps ! Et croyez moi, des projets qui utilisent correctement NgRx √ßa ne court pas les rues, alors leurs propres solutions faites maison‚Ä¶ üò¨

Sachez √©galement que conna√Ætre NgRx aide tr√®s largement √† l‚Äôembauche car beaucoup de projets l‚Äôutilisent. Ma√Ætriser cette outil et l‚Äôindiquer sur son CV est un gros plus.

Enfin, des travaux sont en cours pour proposer un ngrx/signals. Vous pouvez d√©couvrir [la doc ici](https://github.com/markostanimirovic/ngrx-signal-store-playground#ngrx-signals).
Cela semble tr√®s prometteur, le boilerplate est encore plus r√©duit que pour component-store ! J‚Äôai l‚Äôimpression qu‚Äôon reste sur du Command Pattern mais j‚Äôai h√¢te de voir √ßa. Ce n‚Äôest franchement pas impossible qu‚Äô√† terme cela devienne ma solution par d√©faut. A voir quand √ßa sortira ! Je ferai un article dessus of course !

### Des raisons de ne pas utiliser NgRx

Si votre √©quipe n‚Äôarrive pas √† prendre NgRx/store en mains, alors ne l‚Äôutilisez pas. Apr√®s tout le but est d‚Äô√™tre productif, et NgRx/store √† un co√ªt non n√©gligeable en terme d‚Äôapprentissage.

Donc si vous √™tes dans un rush, que vous avez des deadline serr√©es et que le rapport risque/co√ªt n‚Äôest pas bon, utilisez plut√¥t NgRx/component-store voire les Signals en ‚Äúvanilla‚Äù.

Ce n‚Äôest √©videmment pas non plus garanti que votre √©quipe fasse du travail propre avec component-store ou les Signals, mais au moins il n‚Äôy a pas tout une m√©canique √† apprendre, c‚Äôest d√©j√† √ßa !

Mais c‚Äôest ind√©niable : NgRx est verbeux et je comprends que √ßa puisse en rebuter certains. Cependant √† mon sens cette verbosit√© vaut le coup sur le long terme car vous aurez une application parfaitement r√©active, d√©clarative et qui permet une meilleure separation of concerns.

### Conclusion

A la question ‚Äúavez-vous besoin de NgRx‚Äù je r√©ponds : non, vous pouvez faire des applications qualitatives sans.

Mais √† la question ‚Äúavez-vous int√©r√™t √† utiliser NgRx‚Äù, je r√©ponds : **OUI** ! Votre application n‚Äôen sera que plus qualitative, maintenable et suivra de meilleures pratiques qui se reposent sur la programmation d√©claratives et r√©actives !
