---
title: Tout comprendre sur les Signals
description: Tout comprendre sur les Signals dans Angular
---

:::note
Cette article existe √©galement sur [Medium](https://medium.com/@kevin.tale/tout-comprendre-sur-les-signals-dans-angular-7bbbbf00b975/).

S'il vous a plu, n'h√©sitez pas √† me laisser un (ou plusieurs) petit clap üòâ
:::

### Des applications Angular plus performantes avec les Signals‚Ä¶ et avec une meilleure DX ?

Les Signals sont arriv√©s avec Angular 16 ce qui a mis la communaut√© Angular en effervescence ! Mais le sujet est complexe, c‚Äôest pourquoi j‚Äôai √©crit cette article qui compile toutes les infos importantes et qui explique le pourquoi du comment des Signals et comment ils vous aideront dans vos applications Angular.

---

Ok alors revenons aux bases. Les Signals c‚Äôest un sujet complexe, donc on va essayer d‚Äôy aller √©tape par √©tape.

#### Le probl√®me

Consid√©rons ce composant :

```typescript
@Component({
  template: `
    <p>{{ celsius }}</p>
    // 25
    <p>{{ fahrenheit }}</p>
    // 77
  `,
})
export class SomeComponent {
  celsius = 25;
  fahrenheit = this.celsius * 1.8 + 32;
}
```

Ca marche nickel, j‚Äôaffiche 25 degr√©s Celsius et 77 degr√©s Fahrenheit.
Mais que se passe t-il si j‚Äôajoute un bouton pour doubler celsius ?

```typescript
@Component({
  template: `
    // je clique sur ce bouton üëá
    <button (click)="doubleCelsius()">Doubler le degr√© celsius</button>
    <p>{{ celsius }}</p>
    // √ßa me renvoie bien 50
    <p>{{ fahrenheit }}</p>
    // √ßa me renvoie toujours 77 üò±
  `,
})
export class SomeComponent {
  celsius = 25;
  fahrenheit = this.celsius * 1.8 + 32;

  doubleCelsius() {
    this.celsius = this.celsius * 2;
  }
}
```

Patatra, √ßa marche plus ! fahrenheit me renvoie toujours 77. Il n‚Äôa pas √©t√© recalcul√©. Pourquoi ? Et bien cette propri√©t√© est initialis√©e lors de la construction du composant, et seulement √† ce moment-l√†. A aucun momentfahrenheit ne se recalcule, cette propri√©t√© n‚Äôest pas r√©active, √ßa veut dire qu‚Äôelle ne r√©agit pas (elle ne se recalcule pas) lorsque les valeurs auxquels elle d√©pend changent.

Une solution serait de transformer fahrenheit en getter.

```typescript
@Component({
  template: `
    <button (click)="doubleCelsius()">Doubler le degr√© celsius</button>
    <p>{{ celsius }}</p>
    <p>{{ fahrenheit }}</p>
  `,
})
export class AppComponent {
  celsius = 25;

  get fahrenheit() {
    return this.celsius * 1.8 + 32;
  }

  doubleCelsius() {
    this.celsius = this.celsius * 2;
  }
}
```

Et l√†, √ßa fonctionne impec‚Äô ! fahrenheit est bien recalcul√©e quand je clique sur le bouton. Mais comment √ßa marche et pourquoi ce n‚Äôest pas une bonne solution ? En fait, le getter va se recalculer d√®s que la change detection d‚ÄôAngular s‚Äôex√©cute et pas seulement quand celsius change, ce qui est mauvais pour la performance.

Bon‚Ä¶ Quelle est la bonne solution alors ? RxJS to the rescue!
Voyons comment on peut facilement solutionner notre probl√®me avec RxJS.

```typescript
@Component({
  template: `
    <button (click)="doubleCelsius()">Doubler le degr√© celsius</button>
    <p>{{ celsius$ | async }}</p>
    <p>{{ fahrenheit$ | async }}</p>
  `,
})
export class AppComponent {
  celsius$$ = new BehaviorSubject(25);
  celsius$ = this.celsius$$.asObservable();
  fahrenheit$ = this.celsius$.pipe(map((celsius) => celsius * 1.8 + 32));

  doubleCelsius() {
    this.celsius$$.next(this.celsius$$.value * 2);
  }
}
```

Super ! Ca fonctionne tr√®s bien, l‚Äôobservable fahrenheit$ d√©pend de celsius$ , lorsque ce dernier est modifi√© (gr√¢ce √† this.celsiusSubject$$.next()) alors fahrenheit$ est √©galement modifi√©. C‚Äôest ce que l‚Äôon appelle la programmation r√©active car fahrenheit$ ‚Äú√©coute‚Äù ses d√©pendances et r√©agit lorsque la valeur de celles-ci changent.

Quel est le probl√®me alors ?

On en a deux :

1. La performance. Sans entrer trop dans les d√©tails car √ßa pourrait √™tre un article √† part enti√®re, la d√©tection de changement dans Angular fonctionne tr√®s bien mais n‚Äôest pas optimale. Pour g√©rer sa change detection Angular se repose sur zone.js, une librairie tierce qui √©coute tous les √©v√®nements du browser (clique, mouvements de souris, setTimeout, setInterval‚Ä¶) et permet de faire des choses en callback d√®s qu‚Äôun √©v√®nement se termine. Angular tire partie de cela en lan√ßant sa change detection ce qui met √† jour les templates de tous les composants actuellement dans le DOM, et pas seulement sur les composants o√π il y a bel et bien un changement.
2. La complexit√© du code. Comme vous le voyez dans le code au dessus, on doit apprendre et comprendre RxJS pour construire des applications efficaces. Et rares sont ceux qui ma√Ætrisent cette librairie et ses paradigmes. La team Angular a identifi√© que beaucoup de devs‚Äô s‚Äô√©loignent d‚ÄôAngular √† cause de cette complexit√©.

Ils ont donc d√©cider de simplifier les choses.

#### Introducing les Signals

Le principe des Signals n‚Äôest pas une invention d‚ÄôAngular, en fait c‚Äôest un paradigme connu depuis des dizaines d‚Äôann√©es. Et m√™me dans l‚Äô√©cosyst√®me frontend on a d√©j√† des impl√©mentations des Signals (SolidJS, Vue‚Ä¶). Il √©tait donc temps que Angular s‚Äôy mette aussi !

Voici l‚Äô√©quivalent de la fonctionnalit√© d‚Äôavant mais avec les Signals.

```typescript
@Component({
  template: `
    <button (click)="doubleCelsius()">Doubler le degr√© celsius</button>
    <p>{{ celsius() }}</p>
    <p>{{ fahrenheit() }}</p>
  `,
})
export class AppComponent {
  celsius = signal(25);
  fahrenheit = computed(() => this.celsius() * 1.8 + 32);

  doubleCelsius() {
    this.celsius.update((celsius) => celsius * 2);
    this.celsius.set(this.celsius() * 2); // on peut aussi faire comme √ßa, √ßa revient au m√™me
  }
}
```

D√©cortiquons ce qu‚Äôil se passe dans ce composant :

- On cr√©√© notre premier signal avec une valeur par d√©faut : celsius = signal(25) . Son type est `WritableSignal<number>` ce qui signifie que vous pouvez modifier ce signal (il n‚Äôest pas readonly).
- Pour lire la donn√©e actuelle de mon signal, je l‚Äôex√©cute, je le fais √† deux endroits : dans le template et dans la fonctioncomputed. C‚Äôest donc comme cela qu‚Äôon acc√®de √† la valeur courante d‚Äôun signal : celsius(). Et c‚Äôest bien √ßa tout le principe d‚Äôun Signal : c‚Äôest un ‚Äúwrapper‚Äù par dessus une valeur. Quand on ex√©cute la fonction qui wrap la valeur elle nous renvoie la derni√®re valeur connue du signal.
- La fonction computed nous permet d‚Äôobtenir la r√©activit√© que l‚Äôon d√©sire tant ! computedprend une fonction en argument, dans cette fonction on utilise le signal celsius et on return le calcul qui permet de transformer des d√©gr√©s Celsius en Fahrenheit. La magie op√®re d√®s lors que celsius change, en fait d√®s que cela va arriver alors fahrenheit va se recalculer, et tout √ßa gr√¢ce √† computed ! Cette fonctione traque ses d√©pendances (les Signals qui sont ex√©cuter √† l‚Äôint√©rieur) et se r√©ex√©cute d√®s que l‚Äôune d‚Äôentre elles changent et est diff√©rent de la valeur pr√©c√©dente. A noter que le type de retour d‚Äôun computed est `Signal<T>`, et est readonly !
- Pour modifier la valeur d‚Äôun signal, on peut utiliser .update() qui prend en argument une fonction dont l‚Äôargument est la valeur actuelle du signal.
- Alternativement, on peut utiliser .set() pour modifier la valeur d‚Äôun signal si on a pas besoin de sa valeur courante.

Je ne l‚Äôai pas mis dans mon exemple mais nous avons √©galement la fonction effect. effect s‚Äôex√©cute d√®s qu‚Äôun signal utilis√© en son sein change de valeur :

```typescript
@Component({
  template: `
    <button (click)="doubleCelsius()">Doubler le degr√© celsius</button>
    <p>{{ celsius() }}</p>
    <p>{{ fahrenheit() }}</p>
  `,
})
export class AppComponent {
  celsius = signal(25);
  fahrenheit = computed(() => this.celsius() * 1.8 + 32);

  doubleCelsius() {
    this.celsius.update((celsius) => celsius * 2);
  }

  log = effect((onCleanUp) => {
    console.log(`celsius vient de changer, il vaut ${this.celsius()}`);

    onCleanUp(() => {
      console.log("le composant est d√©truit");
    });
  });
}
```

D√®s que le signal celsius changera, alors l‚Äôeffect s‚Äôex√©cutera, car je l‚Äôutilise dans le console.log. Et en plus de cela, les effects ont une cleanup function qui s‚Äôex√©cute au destroy du contexte de l√† o√π il a √©t√© appel√© ! L‚Äôutilit√© de effect est encore sujet √† d√©bat, certains les utilisent pour faire leur call HTTP par exemple. Attendons d‚Äôavoir un peu de recule pour trouver les meilleures use cases.

#### Le gain en performance gr√¢ce aux Signals

Je le disais au d√©but, l‚Äôobjectif est notamment d‚Äôam√©liorer les performances de vos applications Angular. Avec la version 16 nous sommes √† mi-chemin de cet objectif car le framework a pour le moment encore besoin de zone.js pour savoir quand ex√©cuter sa change detection. Mais √ßa ne sera plus le cas tr√®s prochainement car nous pourrons ajouter un attribut signal: true√† nos composants (un peu comme standalone: true) pour compl√®tement se passer de zone.js et ex√©cuter la change detection directement au niveau des composants qui en ont besoin !

Ainsi, la change detection sera ex√©cut√©e uniquement lorsque la valeur d‚Äôun signal utilis√©e dans un template changera et le framework proc√®dera √† la mise √† jour du template uniquement au composant affect√© par le changement et non plus √† l‚Äôarbre entier de composants. C‚Äôest une √©norme diff√©rence ! Nous n‚Äôaurons m√™me plus besoin de changeDetection: ChangeDetectionStrategy.OnPush !

#### Bye bye RxJS alors ?

On a vu que nous n‚Äôavions plus besoin de Subject ou des Observable pour cr√©er nos donn√©es et les modifier, alors plus besoin de RxJS, si ?

Et bien‚Ä¶ Pas si s√ªr !

RxJS ce n‚Äôest pas que des Observable , c‚Äôest aussi des operators. switchMap, filter, tap, debounceTime ‚Ä¶ Tous ces operators sont l√† pour nous faciliter la vie et bon courage pour impl√©menter un switchMap fait maison.

Forte heureusement, la team Angular a pens√© √† nous ! Ils mettent en avant l‚Äôint√©rop√©rabilit√© entre les Signals et RxJS, c‚Äôest √† dire le fait que les deux ‚Äúunivers‚Äù peuvent fonctionner ensemble.

Nous avons donc acc√®s √† deux m√©thodes :

1. toSignal() qui prend un observable et renvoie un signal
2. toObservable() qui prend un signal et renvoie un observable

Voyons comment on peut utiliser √ßa :

```typescript
@Component({
  template: `
    <ul>
      <li *ngFor="let product of availableProducts">
        {{ product.title }}
      </li>
    </ul>
  `,
})
export class AppComponent {
  http = inject(HttpClient);
  // j'utilise httpClient de mani√®re classique pour
  // faire mon call http et passer mes operators rxjs
  availableProducts$ = this.http.get('api/products')
    .pipe(
      filter(product => product.quantity > 0),
      map(...),
      catchError(...)
    );

  // je convertis mon observable en signal avec toSignal.
  // A noter que toSignal() subscribe et unsubscribe automatiquement !
  availableProducts = toSignal(
    this.availableProducts$,
    {initialValue: []} // sinon √ßa √©met "undefined" au d√©but
  );
}
```

Ainsi, on peut toujours profiter de la puissance des operators RxJS et des Signals !

Un autre exemple montrant l‚Äôutilisation de toObservable :

```typescript
@Component({
  template: `
    <input type="number" (input)="changeProductId($event)" />
    <p>{{ product().title }}</p>
  `,
})
export class AppComponent {
  http = inject(HttpClient);

  productId = signal(1);
  product$ = toObservable(this.productId).pipe(
    switchMap((productId) => this.http.get(`api/products/${productId}`))
  );

  product = toSignal(this.product$, { initialValue: {} });

  changeProductId(event: Event) {
    const id = (event.target as HTMLInputElement).value;
    this.productId.set(Number(id));
  }
}
```

On caste en observable le signal qui contient l‚Äôid du produit afin d‚Äô√©couter dessus et d√®s qu‚Äôil change (via l‚Äôinput) on fait un switchMap() en utilisant l‚Äôendpoint avec la valeur de l‚Äôid du produit. Enfin notre propri√©t√© product convertit le r√©sultat en signal.

#### Conclusion

En conclusion, les Signals font partie de la mouvance de la grande renaissance de Angular et vont changer beaucoup de choses. Il faudra attendre que les librairies tierces √©mergent et imposent les bonnes pratiques, je pense notamment √† NgRx. Aussi, la team Angular va certainement passer aux Signals pour ses fonctionnalit√©s genre HttpClient ou les formulaires (rien n‚Äôest s√ªr mais √ßa va s√ªrement arriver t√¥t ou tard).
Donc il est important de se mettre √† jour sur les Signals et vous pouvez compter sur moi pour vous apporter toutes les infos n√©cessaires !
