---
title: Les bonnes pratiques de NgRx en 2023
description: Les bonnes pratiques de NgRx en 2023
---

:::note
Cette article existe √©galement sur [Medium](https://medium.com/@kevin.tale/ngrx-en-2023-les-bonnes-pratiques-a631a366aeaa).

S'il vous a plu, n'h√©sitez pas √† me laisser un (ou plusieurs) petit clap üòâ
:::

J‚Äôutilise NgRx et son √©cosyst√®me depuis 2018 et la moindre des choses qu‚Äôon puisse dire c‚Äôest que NgRx a √©norm√©ment √©volu√© ! Si vous n‚Äôavez pas suivi les nouvelles fonctionnalit√©s de ces deux derni√®res ann√©es, cet article est fait pour vous ! En revanche il est tout de quand m√™me recommand√© de conna√Ætre les bases de NgRx (actions, reducers, selectors) mais je ferai un r√©cap‚Äô de ces notions l√† tout de m√™me et probablement un article √† l‚Äôavenir.

---

J‚Äôavoue avoir √©t√© longtemps g√™n√© par le grand nombre de fichiers d‚Äôun store NgRx, apr√®s tout c‚Äôest vrai que pour la moindre fonctionnalit√©, on est cens√© avoir :

- un fichier actions
- un fichier reducer
- un fichier effects
- un fichier selectors

Et chacun de ces fichiers apportent son lot de verbosit√©.

Mais aujourd‚Äôhui, en 2023, cela n‚Äôa plus rien √† voir, notamment gr√¢ce √† :

- `createFeature` arriv√© en version 12 en septembre 2021
- `createActionGroup` arriv√© en version 13 en mai 2022
- La fonction inject de Angular 14 permettant les functional effects ainsi que d‚Äôautres patterns

Toutes ces fonctionnalit√©s nous permettent de r√©duire grandement la verbosit√© de NgRx et d‚Äôam√©liorer la DX de mani√®re g√©n√©rale, et peut-√™tre m√™me avoir un store avec un seul fichier ?!
Voyons tout cela ensemble !

#### R√©cap‚Äô de NgRx

Avant de rentrer dans le vif de sujet, faisons un petit r√©cap‚Äô de ce qu‚Äôapporte NgRx et des probl√®mes auxquels l‚Äô√©cosyst√®me r√©pond.

En fait, dans la pluspart des applications on aura besoin de g√©rer des donn√©es et de les faire communiquer entre les composants et services : qui d√©tient quelles donn√©es, qui les modifient, comment etc‚Ä¶

Il faut trouver une fa√ßon de faire √ßa efficacement, avec des patterns test√©s et √©prouv√©s, sans r√©inventer la roue. Sinon on va rapidement tomber dans du spaghetti code.

Et c‚Äôest l√† que NgRx entre en jeu !

NgRx est bas√© sur le mod√®le Redux et est adapt√© pour Angular, il offre une structure et une fa√ßon de g√©rer notre √©tat applicatif de fa√ßon d√©terministique, c‚Äôest √† dire qu‚Äôon doit faire ‚Äúcomme √ßa et pas autrement‚Äù !

Cela peut √™tre vu comme un inconv√©nient si la structure n‚Äôest pas agr√©able √† utiliser mais il y a aussi beaucoup d‚Äôavantages : une fa√ßon de faire r√©pandue qui facilite le debugging, la facilit√© √† comprendre le code de ses coll√®gues, la facilit√© √† l‚Äôembauche etc. Et au-del√† de √ßa, NgRx propose de grandes performances, un √©cosyst√®me complet avec les effects, le router store, les pipes et directives, le store-devtools, component-store et bien d‚Äôautres encore.

Nous, on va s‚Äôattarder sur le package principal ngrx/store et on va √©tudier la fa√ßon moderne de l‚Äôutiliser.

#### NgRx Moderne

Je ne vais pas r√©inventer la roue et je vais cr√©er une todos app car elles ont tous les uses cases int√©ressants dont on a besoin pour √©prouver un store NgRx.

Admettons donc que dans cette application, on a un composant TodosComponent qui affiche la liste des todos et permet d‚Äôen ajouter.

```ts
@Component({
  standalone: true,
  imports: [NgFor, FormsModule],
  template: `
    <button (click)="todosFeature.loadTodos()">Load all todos</button>
    <form (ngSubmit)="addTodo()">
      <input name="todoName" [(ngModel)]="todoName" type="text" />
    </form>
    <ul>
      <li *ngFor="let todo of todosFeature.todos()">
        {{ todo.name }}
      </li>
    </ul>
  `,
})
export class ProductsComponent {
  readonly todosFeature = injectTodosFeature(); // c'est ici que la magie op√®re

  todoName = "";

  addTodo() {
    this.todosFeature.addTodo(this.todoName);
    this.todoName = "";
  }
}
```

Que se cache t-il derri√®re injectTodosFeature, telle est la question ! En tout cas, on peut voir qu‚Äôon a todosqui semble √™tre un Signal puisqu‚Äôon l‚Äôex√©cute, et on a √©galement la m√©thode add qui s‚Äôex√©cute au submit du formulaire, cette m√©thode semble ajouter une nouvelle todo avant de vider le champ todoName. Enfin, on a un bouton load all todos.

Bien, essayons ensemble de cr√©er ce store avec ces fonctionnalit√©s dans une toute nouvelle application Angular 16 !

On va commencer par installer NgRx : ng add @ngrx/store.

Puis on va cr√©er le folder todosqui contiendra notre composant et un seul fichier store.ts :

```
src/
  app/
    todos/
      todos.component.ts
      store.ts
    app.component.ts
    app.config.ts // automatiquement g√©n√©r√© depuis Angular 16
    app.routes
  index.html
  main.ts
  style.css
```

C‚Äôest ce seul fichier store.ts qui contiendra notre store. En effet, gr√¢ce aux derni√®res versions de NgRx, l‚ÄôAPI a tellement √©t√© r√©duit qu‚Äôon peut se permettre de faire du single file !

```ts
// todos/store.ts
export type Todo = {
  id: string;
  name: string;
  completed: boolean;
}

export type TodosState {
  todos: Todo[];
}
export const initialState: TodosState = {
  todos: [],
};
```

La premi√®re √©tape consiste toujours √† d√©finir le contrat d‚Äôinterface de notre feature et son √©tat initial. Ici on a donc un tableau de todos initialement vide.

Une fois qu‚Äôon a l‚Äô√©tat initial, on veut d√©finir tous les √©v√®nements qui s‚Äôactionneront au sein de notre feature, et on appelle √ßa les actions ! Une action c‚Äôest comme un √©v√®nement qui va d√©crire quelque chose qui vient d‚Äôarriver dans notre application, et ces actions on les d√©clenche (dans le jargon NgRx on dit qu‚Äôon les dispatche), puis une fois d√©clench√©e, diff√©rentes choses qui √©coutent ces actions (reducers et effects) vont r√©agir et faire des choses, on va voir √ßa ensemble.

On peut imaginer que dans notre todos list on a ces actions l√† :

- Todo cr√©√©e
- Todo modifi√©e
- Todo termin√©e
- Todo supprim√©e
- Reset des todos (pour supprimer tout et reprendre √† z√©ro notre liste)

Dans L‚ÄôANCIENNE fa√ßon de faire, on proc√©dait comme √ßa pour d√©finir les actions :

```ts
import { createAction, props } from "@ngrx/store";

export const addTodo = createAction(
  "[Todos] Add Todo",
  props<{ name: string }>()
);

export const editTodo = createAction(
  "[Todos] Edit Todo",
  props<{ id: string; name: string }>()
);

export const completeTodo = createAction(
  "[Todos] Complete Todo",
  props<{ id: string }>()
);

export const removeTodo = createAction(
  "[Todos] Remove Todo",
  props<{ id: string }>()
);

export const resetTodos = createAction("[Todos] Reset Todos");
```

Chaque action poss√®de sa cha√Æne de caract√®res uniques, c‚Äôest ce qui va permettre √† ceux qui vont √©couter sur ces actions de les diff√©rencier, ce sont leur identifiants uniques. Les props c‚Äôest la donn√©e que l‚Äôaction embarque avec elle pour que ceux qui √©coutent les actions puissent s‚Äôen servir. A noter qu‚Äôune action n‚Äôa pas forc√©ment besoin de props (exemple avec todosReset).

Pour informations, si vous utilisez store-devtools (ce que je vous conseille, j‚Äôy reviendrai plus bas) et bien lorsque vous dispatchez une action c‚Äôest bien ces cha√Ænes de caract√®res que vous verrez dans les logs. Le [Todos] permet d‚Äôidentifier √† quelle feature appartient l‚Äôaction pour nous les devs lorsqu‚Äôon regarde les logs.

Bon, voici la NOUVELLE fa√ßon de faire, attention les yeux :

```ts
export const todosActions = createActionGroup({
  source: "Todos",
  events: {
    "Add Todo": props<{ name: string }>(), // [Todos] Add Todo
    "Edit Todo": props<{ id: string; name: string }>(), // [Todos] Edit Todo
    "Complete Todo": props<{ id: string }>(), // [Todos] Complete Todo
    "Remove Todo": props<{ id: string }>(), // [Todos] Remove Todo
    "Reset Todos": emptyProps(), // [Todos] Reset Todos
  },
});
```

On a une fonction createActionGroup qui prend un objet en param√®tre, cet objet √† une cl√© source qui a pour valeur le nom de la feature (ce nom sera automatiquement entour√© de [] dans les logs) et une cl√© events qui a pour valeur un objet o√π on va lister nos diff√©rentes actions. Dans cet objet, chaque cl√© correspond √† la cha√Æne de caract√®res d√©crivant l‚Äôaction, et sa valeur d√©crit le props. Si on n‚Äôa pas de props il faut mettre emptyProps().

Et ce n‚Äôest pas fini ! En fait, createActionGroup renvoie directement les actions ! Sous quelle forme ? Et bien il se base sur les cha√Ænes de caract√®res des actions pour cr√©er les actions elles-m√™mes !

```ts
export const { addTodo, completeTodo, editTodo, removeTodo, resetTodos } =
  createActionGroup({
    source: "Todos",
    events: {
      "Add Todo": props<{ name: string }>(),
      "Edit Todo": props<{ id: string; name: string }>(),
      "Complete Todo": props<{ id: string }>(),
      "Remove Todo": props<{ id: string }>(),
      "Reset Todos": emptyProps(),
    },
  });
```

Ici, j‚Äôai d√©structur√© ce que renvoie createActionGroup et comme vous le voyez on a une m√©thode addTodo , une autre completeTodo etc. Et c‚Äôest pr√©cis√©ment parce que j‚Äôai appel√© mon action Complete Todo que createActionGroup a cr√©e l‚Äôaction completeTodo, en gros ils mettent l‚Äôaction en lower camel case.

Vous pouvez aussi directement le faire si vous pr√©f√©rez :

```ts
export const todosActions = createActionGroup({
  source: "Todos",
  events: {
    addTodo: props<{ name: string }>(), // [Todos] addTodo
    editTodo: props<{ id: string; name: string }>(), // [Todos] editTodo
    completeTodo: props<{ id: string }>(),
    removeTodo: props<{ id: string }>(),
    resetTodos: emptyProps(),
  },
});
```

Je n‚Äôai personnellement pas de pr√©f√©rence entre l‚Äôun ou l‚Äôautre. Peut-√™tre que cette derni√®re version fait moins magique et plus facilement refactorable, √† vous de voir !

Parlons maintenant de `createFeature`.

Pour faire simple, `createFeature` c‚Äôest √† la fois notre reducer et nos selectors.

Toujours dans le fichier todos/store.ts et √† la suite du code pr√©c√©dent, on ajoute :

```ts
export const todosFeature = createFeature({
  name: 'todos',
  reducer: createReducer(
    initialState,
    on(todosActions.addTodo, (state, action) => ({
      ...state,
      todos: [
        { id: uuid(), title: action.title, completed: false },
        ...state.todos,
      ],
    })),
    on(todosActions.completeTodo, (state, action) => ({
      ...state,
      todos: state.todos.map((todo) =>
        todo.id === action.id ? { ...todo, completed: true } : todo
      ),
    })),
    on(todosActions.editTodo, (state, action) => ({
      ...state,
      todos: state.todos.map((todo) =>
        todo.id === action.id ? { ...todo, title: action.title } : todo
      ),
    })),
    on(todosActions.removeTodo, (state, action) => ({
      ...state,
      todos: state.todos.filter((todo) => todo.id !== action.id),
    })),
    on(todosActions.loadTodosSuccess, (state, action) => ({
      ...state,
      todos: action.todos,
    })),
    on(todosActions.resetTodos, (state) => ({
      ...state,
      todos: [],
    }))
  ),
```

createFeature prend un objet avec deux propri√©t√©s : name qui est le nom de notre feature et reducer qui est notre reducer classique qu‚Äôon utilise comme √† l‚Äôaccoutum√©.

Ce qui est int√©ressant c‚Äôest ce que return createFeature :

```ts
export const {
  name, // le nom de notre feature ("todos" ici)
  reducer, // le reducer de notre feature
  selectTodosState, // le selector global de notre feature
  selectTodos, // le selector de la propri√©t√© "todos"
} = createFeature({
  name: 'todos',
  reducer: createReducer(...)
})
```

Et oui ! createFeature va automatiquement cr√©er des selectors en se basant sur les propri√©t√©s de notre state ! Pour rappel, mon state est celui-ci :

```ts
export type TodosState {
  todos: Todo[];
}
```

Ainsi, createFeature va cr√©er un selector automatiquement pour chacune des propri√©t√©s du state sous la forme selectXXX , par exemple si j‚Äôavais une propri√©t√© loading en plus de todos , √ßa aurait cr√©√© automatiquement selectLoading. Dingue non ?

Et si on a besoin de selectors en plus, createFeaturea une propri√©t√© suppl√©mentaire appel√©e extraSelectors et comme son nom l‚Äôindique celle-ci nous permet de cr√©er d‚Äôautres selectors √† notre guise :

```ts
export const {
  ...
  selectTodos,
  selectHasTodos, // le nouveau selector que je viens de cr√©er !
  selectCompletedTodos // le nouveau selector que je viens de cr√©er !
} = createFeature({
  name: 'todos',
  reducer: createReducer(...),
  extraSelectors: ({selectTodos}) => {
    return {
      selectHasTodos: createSelector(selectTodos, (todos) => todos.length > 0),
      selectCompletedTodos: createSelector(selectTodos, (todos) => todos.filter((todo) => todo.completed)),
    }
  }
})
```

extraSelectors prend une fonction en valeur, l‚Äôargument de cette fonction est un objet qui contient chacun de nos selectors d√©j√† existant, ici je d√©structure selectTodos pour cr√©er deux autres nouveaux selectors : selectHasTodos et selectCompletedTodos ! C‚Äôest aussi simple que √ßa !

Personnellement j‚Äôadore cette nouvelle fa√ßon de faire, je trouve √ßa tr√®s agr√©able √† utiliser.

Bon, nous avons nos actions, nos selectors, notre reducer‚Ä¶ Il nous reste les effects !

Je vous en parlais en introduction, gr√¢ce √† la fonction inject() arriv√©e avec Angular 14, nous avons acc√®s aux functional effects. L‚Äôid√©e est de pouvoir √©crire des effects en dehors de class. Avant nous √©tions oblig√© d‚Äôutiliser un Injectable (donc une class) car on injectait Actions de @ngrx/effects dans son constructor. Mais ce n‚Äôest plus le cas maintenant.

Voyons √† quoi √ßa ressemble :

```ts
export const loadTodos$ = createEffect(
  (actions$ = inject(Actions)) => {
    const http = inject(HttpClient);

    return actions$.pipe(
      ofType(todosActions.loadTodos),
      switchMap(() =>
        http.get<Todo[]>("https://jsonplaceholder.typicode.com/todos").pipe(
          map((todos) => todosActions.loadTodosSuccess({ todos })),
          catchError((error) => of(todosActions.loadTodosFailure({ error })))
        )
      )
    );
  },
  { functional: true }
);
```

Comme vous le voyez, on injecte actions$ gr√¢ce √† la fonction inject(), de ce fait nous n‚Äôavons pas besoin d‚Äôinclure nos effects dans des class, d‚Äôo√π l‚Äôappellation functional effects ! On doit simplement ajouter `{ functional: true }` pour que √ßa fonctionne.

Si on a besoin d‚Äôinjecter un service dans notre effect, on peut le faire comme √ßa :

```ts
export const loadTodos$ = createEffect(
  (actions$ = inject(Actions), todosService = inject(TodosService)) => {
    return actions$.pipe(
      ofType(todosActions.loadTodos),
      switchMap(() =>
        todosService.getAll().pipe(
          map((todos) => todosActions.loadTodosSuccess({ todos })),
          catchError((error) => of(todosActions.loadTodosFailure({ error })))
        )
      )
    );
  },
  { functional: true }
);
```

A noter que nous ne sommes pas oblig√©s d‚Äôinjecter dans les arguments de la fonction de l‚Äôeffect, voil√† √† quoi √ßa ressemble en injectant directement dans le body de createEffect:

```ts
export const loadTodos = createEffect(
  () => {
    const todosService = inject(TodosService);
    return inject(Actions).pipe(
      ofType(todosActions.loadTodos),
      switchMap(() =>
        todosService.loadAll().pipe(
          map((todos) => todosActions.loadTodosSuccess({ todos })),
          catchError((error) => of(todosActions.loadTodosFailure({ error })))
        )
      )
    );
  },
  { functional: true }
);
```

Mais il n‚Äôest pas recommand√© de le faire pour faciliter le testing.

Aussi, dans les faits on peut faire du full single file et mettre nos effects dans le m√™me fichier, mais √ßa peut vite monter √† 300/400/500 lignes. Personnellement √ßa ne me d√©range pas d‚Äôavoir un long fichier si le code est propre. J‚Äôai toujours pr√©f√©r√© scroller que cliquer pour changer de fichiers. Mais si ce n‚Äôest pas votre cas, n‚Äôh√©sitez pas √† faire un autre fichier pour s√©parer vos effects !

Ok ! Vous vous rappelez que dans le composant que j‚Äôai montr√© tout en haut, on a un readonly todosFeature = injectTodosFeature(); ? Et bien on va cr√©er √ßa, et encore une fois c‚Äôest gr√¢ce √† la fonction inject(). A la fin de notre todos/store.ts, on ajoute :

```ts
export function injectTodosFeature() {
  const store = inject(Store);

  return {
    addTodo: (name: string) => store.dispatch(todosActions.addTodo({ name })),
    removeTodo: (id: string) => store.dispatch(todosActions.removeTodo({ id })),
    resetTodos: () => store.dispatch(todosActions.resetTodos()),
    loadTodos: () => store.dispatch(todosActions.loadTodos()),,
    todos: store.selectSignal(todosFeature.selectTodos),
    hasTodos: store.selectSignal(todosFeature.selectHasTodos),
    completedTodos: store.selectSignal(todosFeature.selectCompletedTodos),
  };
}
```

C‚Äôest tout simplement une fonction qui va return un objet avec tous les dispatch d‚Äôactions et selectors dont on a besoin. Au final c‚Äôest comme une fa√ßade ! C‚Äôest tr√®s pratique car √ßa nous permet d‚Äôexposer √† l‚Äôext√©rieur uniquement ce que les consommateurs du store auront besoin.

Vous aurez noter que j‚Äôutilise le nouveau store.selectSignal(), qui prend en argument en selector et qui renvoie le transforme en Signal. Si vous voulez en savoir plus sur les Signals, j‚Äôai fait un article complet √† ce sujet.

Et voil√† ! Notre store est termin√©. Il ne reste plus qu‚Äô√† le brancher pour que √ßa fonctionne. Ici, deux solutions, si vous voulez que votre store soit initialis√© au bootstrap de l‚Äôapplication, il faudra aller dans votre app.config.ts (ou main.ts ) :

```ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(),
    provideStore(), // pour que @ngrx/store fonctionne
    provideState(todosFeature), // on initialise notre store
    provideEffects({ loadTodos }), // on provide nos effects
  ],
};
```

Vous pouvez aussi provide votre store au niveau d‚Äôune route comme √ßa il ne se d√©clenchera que lorsque l‚Äôutilisateur est sur cette route :

```ts
// app.routes.ts

export const routes: Routes = [
  {
    path: "",
    redirectTo: "todos",
    pathMatch: "full",
  },
  {
    path: "todos",
    loadComponent: () => import("./routes/todos/todos.route"),
    providers: [provideState(todosFeature), provideEffects({ loadTodos })],
  },
];
```

Tout est pr√™t ! Vous pouvez maintenant utiliser votre store dans vos composants !üí™

#### Conclusion

Personnellement j‚Äôavais pendant longtemps d√©laiss√© ngrx/store au profit de ngrx/component-store car je pr√©f√©rais le fait qu‚Äôil y ait moins de fichiers et de verbosit√© de mani√®re g√©n√©rale. Maintenant l‚Äôargument ne tient plus vraiment, avec la version moderne de NgRx je pr√©f√®re largement l‚Äôutiliser. Sa rigueur, les patterns qu‚Äôil impose et les devtools (absents de component-store) me plaisent et je f√©licite l‚Äô√©quipe de NgRx d‚Äôavoir trait√© le plus gros soucis de NgRx : la DX. üëè

Code source : https://github.com/KevTale/ngrx-moderne
Article sur NgRx 16 : https://dev.to/ngrx/announcing-ngrx-v16-integration-with-angular-signals-functional-effects-standalone-schematics-and-more-5gk6
