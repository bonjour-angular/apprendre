---
title: Tout ce que je sais sur RxJS
description: Tout ce que je sais sur RxJS
---

import { Image } from "astro:assets";

:::note
Cette article existe √©galement sur [Medium](https://medium.com/@kevin.tale/tout-ce-que-je-sais-sur-rxjs-partie-1-7af99a9edded).

S'il vous a plu, n'h√©sitez pas √† me laisser un (ou plusieurs) petit clap üòâ
:::

L‚Äôautre jour un membre de ma communaut√© Discord a pos√© une question tr√®s int√©ressante

<div style="display: flex; justify-content: center">
  <Image
    src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*U-8acQ7GrLZ40se4a8jLYA.png"
    width="750"
    height="350"
    alt="pourquoi et quand utiliser un behaviorSubject au lieu d'un Observable?"
  />
</div>

Je lui ai √©crit une r√©ponse qui m‚Äôa pris 45min √† r√©diger tant cette question implique beaucoup de choses. Et √ßa m‚Äôa donn√© l‚Äôenvie de me lancer dans un article sur un sujet que j‚Äôaime : RxJS. Et la question Observable vs Subject est un bel angle par lequel √©tudier tout cela.

Alors faisons un grand plongeon dans RxJS pour essayer de d√©mystifier de mani√®re la plus simple possible tous les rouages de cette librairie.

---

RxJS, √ßa devrait vous √™tre familier. C‚Äôest une librairie qui permet de g√©rer l‚Äôasynchronicit√© des √©v√®nements et des donn√©es au sein d‚Äôune application Javascript, et RxJS est largement utilis√© dans Angular.

Et m√™me si les Signal vont probablement r√©duire l‚Äôutilisation de la librairie, ce n‚Äôest pas pr√©vu de si t√¥t et √ßa ne sera pas compl√®tement le cas, alors faisons un point sur une question fondamentale qui va nous permettre de comprendre RxJS dans son int√©gralit√© : c‚Äôest quoi la diff√©rence entre un Observable et un Subject ?

Avant de parler de leurs diff√©rences, parlons de leurs ressemblances.

```ts
import { Observable, Subject } from "rxjs";

const obs = new Observable();
const sub = new Subject();
```

Ce qu‚Äôon peut voir, c‚Äôest que ce sont tous les deux des class que l‚Äôon peut instancier.

```ts
import { Observable, Subject } from "rxjs";

const obs = new Observable();
const sub = new Subject();

obs.subscribe((data) => console.log(`Obs ${data}`));
sub.subscribe((data) => console.log(`Sub ${data}`));
```

Mais l‚Äôint√©r√™t de ces deux class, c‚Äôest surtout qu‚Äôon peut s‚Äôabonner dessus avec la fonction subscribe. ‚ÄúS‚Äôabonner‚Äù veut dire qu‚Äô√† l‚Äôinstant o√π une donn√©e va √™tre pouss√©e dans l‚ÄôObservable ou le Subject alors ces derniers vont √©mettre cette donn√©e, ainsi chaque abonn√© va recevoir cette nouvelle donn√©e imm√©diatement et ce qu‚Äôil y a dans le .subscribe()va se trigger.

On peut donc en conclure que les Observable et Subject permettent de cr√©er des flux de donn√©es, ce flux est continu, il ne s‚Äôinterrompt pas (sauf si on lui dit explicitement). Et pour ouvrir ce flux de donn√©es, il faut s‚Äôabonner en utilisant .subscribe().

Dans mon exemple je me suis abonn√© √† la fois √† obs et sub, ainsi d√®s qu‚Äôune donn√©e va √™tre pouss√©e dans l‚Äôun ou l‚Äôautre alors le console.log va s‚Äôex√©cuter.

Mais pas avant !

Ce que je veux dire par l√†, c‚Äôest que si j‚Äôex√©cute ce script, rien ne va s‚Äôafficher. Pourquoi ? Parce qu‚Äô√† aucun moment je n‚Äôai pouss√© de nouvelle donn√©e. Mes deux abonnements sont faits, les flux sont ouverts, mais √©tant donn√© que je n‚Äôai pas encore pouss√© de donn√©e alors obsou sub n‚Äô√©mettent rien, donc je ne rentre pas dans le callback du tout.

En r√©sum√©, voil√† comment le d√©roul√© de ‚Äúvie‚Äù d‚Äôun Observable (√ßa marche pareil pour un Subject)

1. Je cr√©√© l'Observable avec const obs = new Observable();
2. Dans divers endroits de mon application je m‚Äôabonne √† mon Observable en faisant obs.subscribe(...)
3. D√®s qu‚Äôune donn√©e est pouss√©e dans l‚Äô Observable (on va voir comment juste apr√®s) alors obs va l‚Äô√©mettre, en d‚Äôautres termes il va la pousser dans son flux
4. Les abonn√©es vont recevoir cette donn√©e car ils √©coutent le flux et pourront faire des trucs divers et vari√©s avec cette donn√©e

#### .next() pour pousser des donn√©es

```ts
import { Subject } from "rxjs";

const sub = new Subject();

sub.subscribe((data) => console.log(`Sub ${data}`));

sub.next("Salut !");
```

Mesdames et messieurs, devant aux yeux √©bahis je viens de pousser une donn√©e dans sub ! üëè

Maintenant, que se passe t-il si j‚Äôex√©cute ce code ? Et bien vous l‚Äôaurez devin√©, je verrais Sub Salut ! qui provient du console.log(`Sub ${data}`). Tout simplement parce que lorsque j‚Äôai faitsub.next('Salut !), j‚Äôai pouss√© une nouvelle donn√©e dans le Subject et ce dernier l‚Äôa √©mise, ainsi tous les abonn√©s l‚Äôont re√ßues.

Je dis bien ‚Äútous les abonn√©s‚Äù car je peux m‚Äôabonner plusieurs fois :

```ts
import { Subject } from "rxjs";

const sub = new Subject();

sub.subscribe((data) => console.log(`Sub1 ${data}`));
sub.subscribe((data) => console.log(`Sub2 ${data}`));
sub.subscribe((data) => console.log(`Sub3 ${data}`));

sub.next("Salut !");
```

Ainsi, tous les abonn√©s vont recevoir cette m√™me valeur. A noter que si j‚Äôavais mis le sub.next('Salut !'); avant les subscribe() alors les abonn√©s n‚Äôauraient re√ßu aucune donn√©e car la valeur aurait √©t√© √©mise avant un quelconque abonnement.

#### Utiliser les Subject dans Angular

Mais alors √† quoi √ßa sert ? Comment tirer profit de cela ?

Et bien RxJS est tr√®s utile dans le monde JS pour g√©rer des √©v√®nements de mani√®res isol√©es. Par exemple si je veux que le clique d‚Äôun bouton mette √† jour un compteur et que la valeur de ce compteur soit affich√© dans plusieurs composants diff√©rents au sein de mon application, je peux utiliser un Subject. Ce Subject je vais le cr√©er dans un fichier √† part et pas directement dans un composant car sa valeur n‚Äôappartient √† aucun composant en particulier. Et ce fichier, dans le cas de Angular, sera un service.

```ts
@Injectable({providedIn: 'root'})
export class CounterService {
  readonly count = new Subject<number>();

  constructor() {
    this.count.next(0); // j'initialise la valeur √† 0
  }

  increment() {
    this.count.next(???);
  }

}
```

Attendez une minute‚Ä¶ Comment on fait pour r√©cup√©rer la valeur actuelle de count pour l‚Äôincr√©menter ?

BehaviorSubject √† la rescousse !

```ts
import { BehaviorSubject } from "rxjs";

@Injectable({ providedIn: "root" })
export class CounterService {
  readonly count = new BehaviorSubject<number>(0);

  increment() {
    this.count.next(this.count.value + 1);
  }
}
```

BehaviorSubject c‚Äôest une autre class qui vient de RxJS et qui est tr√®s similaire √† Subject, sauf que :

- BehaviorSubject a une notion de ‚Äúvaleur courante‚Äù. Quand un BehaviorSubject √©met une donn√©e, il va √©galement l‚Äôenregistrer en son sein. Par cons√©quent, on a acc√®s √† la propri√©t√© .value qui va nous renvoyer cette valeur
- Quand on initialise un BehaviorSubject on doit lui passer une valeur initiale, c‚Äôest exactement ce que je fais en faisant `readonly count = new BehaviorSubject<number>(0)`. Du coup, plus besoin de faire le this.count.next(0) dans le constructor !

Plut√¥t pas mal non ? Je peux maintenant utiliser les valeurs √©mient par count en m‚Äôabonnant √† celui-ci directement dans mes composants et √©galement pousser une valeur incr√©ment√©e :

```ts
@Component({
  standalone: true,
  template: `
    <p>Counter: {{ count }}</p>
    <button (click)="counterService.increment()">+1</button>
  `,
})
export class SomeComponent implements OnInit {
  readonly countService = inject(CounterService);
  count!: number;

  ngOnInit() {
    this.countService.count.subscribe((value) => (this.count = value));
  }
}
```

Je peux impl√©menter cette fonctionnalit√© partout o√π je veux dans mon application, certains autres composants pourraient utiliser une fonction decrement, ou simplement afficher la valeur de count. J‚Äôai une application o√π la separation of concerns est respect√©e ! Le CounterService cr√©√© est ce qu‚Äôon appelle un ‚Äústore‚Äù : une source de v√©rit√© qui contient mes donn√©es, le moyen d‚Äôacc√©der √† ces donn√©es par d‚Äôautres briques de mon application, et les m√©thodes qui modifient ces donn√©es.

En bref, utilisez BehaviorSubject lorsque vous voulez cr√©√© un store manuellement sans librairie ti√®rce ! C‚Äôest d‚Äôailleurs ce qu‚Äôutilise NgRx sous la capot.

Mais‚Ä¶ Mon impl√©mentation actuel est loin d‚Äô√™tre parfaite ! Am√©liorons tout √ßa en introduisant une notion : les Observable.

```ts
import { Observable } from "rxjs";

@Injectable({ providedIn: "root" })
export class CounterService {
  private readonly count = new BehaviorSubject<number>(0);
  readonly count$ = this.count.asObservable();

  increment() {
    this.count.next(this.count.value + 1);
  }
}
```

Ici il y a deux diff√©rences :

- J‚Äôai cr√©√© une propri√©t√© publique count$ qui est √©gale √† this.count.asObservable()
- J‚Äôai mis le BehaviorSubject en priv√©

count$ est donc un Observable gr√¢ce √† .asObservable(). Un Observable est un flux de donn√©es tout comme un Subject ce qui signifie qu‚Äôon peut faire un subscribe() dessus. Mais la grande diff√©rence est la suivante : sur un Observable on ne peut pas faire de .next().

Un Observable est comme un Subject mais read-only, on ne peut pas lui pousser des donn√©es. C‚Äôest donc tr√®s utile pour exposer aux autres parties de mon application des donn√©es sans leurs donner la possibilit√© de les modifier directement car cette responsabilit√© incombe au service o√π est d√©clar√©e ma donn√©e.

Je peux donc changer le code de mon composant afin d‚Äôutiliser count$, j‚Äôen profite le rendre plus optimal en utilisant le pipe async qui a pour but subscribe automatiquement et de unsubscribe quand mon composant est d√©truit (par exemple quand je change de page) :

```ts
@Component({
  standalone: true,
  template: `
    <p>Counter: {{ countService.count$ | async }}</p>
    <button (click)="counterService.increment()">increment</button>
  `,
})
export class SomeComponent {
  readonly countService = inject(CounterService);
}
```

#### Comment fonctionne les Observable

Allons plus loin dans la d√©couverte des Observable en n‚Äôen cr√©ant un.

```ts
import { Observable } from "rxjs";

const obs = new Observable();
```

Comme je le disais plus haut, cet obs ne fait rien, en r√©alit√© on ne cr√©√© jamais d‚Äô Observable comme √ßa car un Observable attend une fonction en callback :

```ts
import { Observable } from "rxjs";

const obs = new Observable((subscriber) => {
  subscriber.next("Salut !");
});

obs.subscribe((data) => console.log(data)); // Salut !
```

C‚Äôest en r√©alit√© dans le callback d‚Äôun Observable que l‚Äôon doit faire notre .next(), et on le fait sur l‚Äôargument subscriber qui correspond en r√©alit√© au flux de donn√©es que chaque abonn√© √©coutera lorsqu‚Äôil fera .subscribe().

```ts
import { Observable } from "rxjs";

const obs = new Observable((subscriber) => {
  subscriber.next("Salut ");
  subscriber.next("comment ");
  subscriber.next("√ßa va ?");
});

obs.subscribe((data) => console.log(data));
```

Ici je vais bel et bien avoir 3 console.log() comme ceci :

```
Salut ! // premier console.log
comment // deuxi√®me console.log
√ßa va ? // troisi√®me console.log
```

Mon Observable, et plus particuli√®rement son callback, fait 3 .next() sur le flux de donn√©es, poussant donc 3 valeurs, ainsi au moment o√π je vais subscribe() le flux va √©mettre trois fois, donc je passerai 3 fois √† l‚Äôint√©rieur du subscribe().

Il est important de comprendre que c‚Äôest le fait de .subscribe() qui d√©clenche l‚Äôouverture du flux et donc qui trigger le callback pass√© dans le Observable. C‚Äôest exactement comme le http.get() (et les autres requ√™tes) du HttpClient de Angular, si je ne subscribe() pas, le call http ne se lance pas. A chaque fois qu‚Äôon va subscribe() √ßa d√©clenchera un nouveau call http et cr√©era un nouveau flux ind√©pendant.

#### `Observable` et valeurs dynamiques

Les Observable ne vont pas syst√©matiquement pousser des donn√©es statiques !

```ts
import { Observable } from "rxjs";

const rand = new Observable((subscriber) => {
  subscriber.next(Math.random());
});

rand.subscribe((data) => console.log(data)); // 0.159812
rand.subscribe((data) => console.log(data)); // 0.811699
rand.subscribe((data) => console.log(data)); // 0.422368
```

Comme vous le voyez, la donn√©e que l‚Äôon pousse dans le .next() n‚Äôest pas forc√©ment une valeur fig√©e. Ici c‚Äôest Math.random() que je pousse. De ce fait √† chaque subscribe() le Math.random() va √™tre execut√©, on aura donc une valeur diff√©rente.

Un autre exemple :

```ts
const counter = new Observable((subscriber) => {
  let counter = 0;
  setInterval(() => {
    subscriber.next(counter++);
  }, 1000);
});

counter.subscribe((data) => console.log(data)); // √©met toutes les secondes

// 5 secondes plus tard je m'abonne √† nouveau
setTimeout(() => {
  counter.subscribe((data) => console.log(data)); // √©met toutes les secondes
}, 5000);
```

counter d√©clenche un intervalle o√π chaque seconde une nouvelle donn√©e est pouss√©e, donc chaque abonnement va cr√©er un nouvel intervalle. J‚Äôai fait d√©marrer le second abonnement 5 secondes plus tard juste pour vous montrer que les flux sont vraiment ind√©pendants.

Et c‚Äôest une diff√©rence fondamentale entre les Observable et les Subject !

- Avec les Observables, chaque abonn√© cr√©√© un flux de donn√©es ind√©pendant entre lui et l‚Äô Observable d√®s qu‚Äôil .subscribe(). On dit alors que les Observable font du unicasting.
- Avec les Subject, tous les abonn√©s se branchent au m√™me flux de donn√©es en faisant un .subscribe()et d√®s que le Subject √©met suite √† un .next() alors les abonn√©s vont tous recevoir cette nouvelle valeur. On dit alors que les Subjectfont du multicasting.

Et cette diff√©rence repose uniquement sur la question de l‚Äôendroit o√π se fait le .next(), et en r√©alit√© c‚Äôest tout √† fait logique, regardez cet exemple :

```ts
import { Observable, Subject } from "rxjs";

const randObs = new Observable((subscriber) => {
  subscriber.next(Math.random());
});

randObs.subscribe(console.log);
randObs.subscribe(console.log);
randObs.subscribe(console.log);

const randSub = new Subject();

randSub.subscribe(console.log);
randSub.subscribe(console.log);
randSub.subscribe(console.log);

randSub.next(Math.random());
```

Les trois abonn√©s sur randObs sont compl√®tement ind√©pendant, et d√®s qu‚Äôils ont subscribe() ils ont cr√©√© un nouveau flux et relancer un nouveau Math.random(), donc ils n‚Äôont pas re√ßu la m√™me valeur !

Tandis que pour le Subject, j‚Äôai d‚Äôabord cr√©√© trois abonnements puis je pousse un nouveau Math.random() donc les trois abonnements vont bien recevoir la m√™me chose !

C‚Äôest √©galement le cas avec un BehaviorSubject :

```ts
const randSub = new BehaviorSubject(Math.random());

randSub.subscribe(console.log);
randSub.subscribe(console.log);
randSub.subscribe(console.log);
```

Les trois abonn√©s vont recevoir la m√™me donn√©e initiale, pourquoi ? Et bien tout simplement parce qu‚Äôun BehaviorSubject ex√©cute ce qu‚Äôon lui passe en param√®tre d√®s qu‚Äôil se cr√©√©.

#### Le parall√®le avec Angular

Bon, c‚Äôest int√©ressant tout √ßa, mais comment √ßa s‚Äôinscrit dans la logique de cr√©ation d‚Äôun application Angular ?

En fait, vous n‚Äôallez quasiment jamais faire de new Observable, en tout cas personnellement en 7 ans d‚Äôutilisation d‚ÄôAngular je ne l‚Äôai pas fait une seule fois. Tandis que new Subject ou new BehaviorSubject est relativement commun (moins si vous utilisez une librairie de State Management car celles-ci l‚Äôutilisent d√©j√† sous le capot), √ßa vous servira √† cr√©er ce pattern o√π vous aurez une donn√©e ind√©pendante que vous pourrez lire et √©crire depuis n‚Äôimporte quel composant ou service en respectant une separation of concerns.

En revanche, vous allez beaucoup utiliser les Observables mis √† disposition par Angular :

- Le `HttpClient` et ses requ√™tes qui renvoient des `Observables`
- `ActivatedRoute` qui permet de s‚Äôabonner √† la route courante
- `valueChanges` pour √©couter les changements de valeurs des diff√©rents champs d‚Äôun formulaire
- Et bien d‚Äôautres

D‚Äôailleurs on peut facilement imaginer ce √† quoi pourrait ressembler l‚Äôimpl√©mentation de `http.get()` de Angular :

```ts
const httpGet = (endpoint: string) => new Observable(subscriber => {
  // ici il y a la requ√™tte HTTP avec xhr en
  // utilisant l'endpoint en param√®tre
  const resultFromHttpRequest = ...;
  subscriber.next(dataFromHttpRequest);
  subscriber.complete()
})
```

Bien entendu la vraie impl√©mentation de la fonction est plus complexe car on g√®re les erreurs, les side effects, le HttpHeader etc, mais dans l‚Äôid√©e c‚Äôest bien √ßa ! Le subscriber.complete() sert √† couper le flux de tous les abonn√©s, dans les requ√™tes de HttpClient c‚Äôest fait automatiquement.

D‚Äôailleurs en parlant de √ßa, subscribe() ne prend pas forc√©ment qu‚Äôune fonction callback, on peut aussi lui passer un objet pour pr√©ciser quoi faire en cas d‚Äôerreur ou lors du complete (quand le flux est coup√©) :

```ts
const obs = new Observable((subscriber) => {
  try {
    subscriber.next(Math.random());
    subscriber.complete();
  } catch (error) {
    throw new Error(error);
  }
});

obs.subscribe({
  next: (data) => console.log(data),
  error: (error) => console.error(error),
  complete: () => console.log("complete"),
});
```

- next() va s‚Äôex√©cuter √† chaque √©mission de nouvelle donn√©e
- error va s‚Äôex√©cuter quand obs va lever une erreur
- complete va s‚Äôex√©cuter quand le flux va se couper

#### Les op√©rateurs

Ces outils puissants (et parfois difficiles √† ma√Ætriser) vous permettront d‚Äôappr√©hender la programmation r√©active au sein de vos applications Angular. Pour guider la suite de cette article, nous tenterons de r√©pondre √† deux questions :

1. Qu‚Äôest-ce qu‚Äôun op√©rateur RxJS?
2. Quels sont les op√©rateurs les plus utilis√©s et pour quelles raisons ?

##### Qu‚Äôest-ce qu‚Äôun op√©rateur RxJS ?

Comme vous le savez d√©j√†, un Observable est un m√©canisme de gestion de flux de donn√©es. Chaque fois qu‚Äôune donn√©e est inject√©e dans un Observable (via une m√©thode .next()), cette donn√©e est √©mise √† tous les abonn√©s (via un subscribe()ou | async).

C‚Äôest l√† qu‚Äôinterviennent les op√©rateurs. Leur r√¥le est d‚Äôintervenir dans le flux de donn√©es et de faire quelque chose √† chaque √©mission, par exemple transformer la donn√©e, la filtrer, et bien d‚Äôautres encore.

Il existe √©galement des op√©rateurs qui vont cr√©er des Observables √† partir de rien, ceux-l√† ne vont donc pas modifier les valeurs √©mient mais bel et bien construire leurs propres flux.

Il existe donc deux grandes cat√©gories d‚Äôop√©rateurs :

1. les op√©rateurs de r√©action, car ils font quelque chose √† chaque √©mission de donn√©e
2. les op√©rateurs de cr√©ation, car ils permettent de cr√©er des Observables

Voici un exemple qui illustre comment utiliser les op√©rateurs dans un contexte Angular :

```ts
import { interval } from "rxjs";

@Component({
  template: `Compteur : {{ counter$ | async }}`,
})
export class AppComponent {
  // va √©mettre 0..1..2..3..4.. chaque seconde d√®s qu'on s'abonne
  readonly counter$ = interval(1000);
}
```

Dans cet exemple, gr√¢ce √† l‚Äôop√©rateur de cr√©ation interval(), j‚Äôai cr√©e un Observable qui va √©mettre 1, puis 2, puis 3, puis 4 etc chaque seconde (car j‚Äôai pr√©cis√© 1000 dans ses param√®tres) d√®s lors qu‚Äôon s‚Äôabonne dessus, c‚Äôest donc utile pour faire des compteurs.

Maintenant, admettons que j‚Äôai envie de doubler la valeur de chacune des √©missions. Je pourrais faire comme √ßa :

```ts
import { interval } from "rxjs";

@Component({
  template: `Compteur : {{ counter }}`,
})
export class AppComponent {
  doubleCounter = 0;
  readonly counter$ = interval(1000).subscribe(
    (value) => (this.doubleCounter = value * 2)
  );
}
```

Cela marcherait tr√®s bien, mais imaginez que j‚Äôai besoin de ce compteur doubl√© √† plusieurs endroits dans mon application, je devrais refaire √ßa √† chaque fois, donc pas top pour d‚Äô√©ventuelles √©volutions ou refacto et en plus il faut penser au unsubscribe.

Et c‚Äôest exactement l√† que les op√©rateurs entrent en jeu.

```ts
import { interval, map } from "rxjs";

@Component({
  template: `Compteur : {{ doubleCounter$ | async }}`,
})
export class AppComponent {
  // va √©mettre 0..2..4..6..8.., chaque seconde
  readonly doubleCounter$ = interval(1000).pipe(map((value) => value * 2));
}
```

Les op√©rateurs se mettent dans myObs$.pipe(...), il faut vraiment le voir comme une op√©ration qui se d√©clenche √† chaque √©mission. Ici, j‚Äôutilise l‚Äôop√©rateur map qui a pour but de transformer la donn√©e √† chaque √©mission, et l√† en l‚Äôoccurrence je double sa valeur.

Et ce qui est formidable (et tr√®s important), c‚Äôest qu‚Äôon peut enchainer les op√©rateurs dans la fonction pipe.

```ts
import { interval, map } from "rxjs";

@Component({
  template: `Compteur : {{ doubleCounter$ | async }}`,
})
export class AppComponent {
  readonly doubleCounter$ = interval(1000).pipe(
    tap((value) => console.log(value)), // 0..1..2..3..
    map((value) => value * 2), // double la donn√©e √† chaque √©mission
    tap((value) => console.log(value)), // 0..2..4..6..
    filter((value) => value > 10) // bloque les √©missions si inf√©rieur √† 10
  );
}
```

Ici on fait pleins de trucs :

- `tap` a pour but d‚Äôeffectuer des effets de bords, c‚Äôest √† dire qu‚Äôon ne modifie pas le flux actuel, mais on y a acc√®s quand m√™me. Ici je l‚Äôutilise deux fois, la premi√®re fois pour faire un console.log AVANT le map et la seconde fois APRES. C‚Äôest tr√®s utile pour se rendre compte de ce qu‚Äô√©met notre Observable.
- `map` modifie chaque √©mission, comme dit pr√©c√©demment.
- `filter` qui va bloquer les √©missions si la valeur renvoy√©e par la fonction est false. Ici donc l‚ÄôObservable ne va √©mettre que si la valeur est plus grande que 10.

Les op√©rateurs sont donc un excellent moyen de contr√¥ler nos flux de donn√©es ! C‚Äôest difficile de se rendre compte de la puissance des op√©rateurs donc je vous invite √† essayer par vous-m√™me sur ce lien Stackblitz.

##### Mais √† quoi √ßa sert tout √ßa ?

‚ÄúJe pourrais faire la m√™me chose avec une fonction qui utilise un setInterval et quelques if non ?‚Äù

C‚Äôest vrai, mais RxJS vous ouvre les voies de la programmation r√©active et d√©clarative. C‚Äôest √† dire que vous d√©clarez ce qui doit se passer en r√©ponse √† certains √©v√©nements, sans avoir √† vous soucier des d√©tails de mise en ≈ìuvre.

Avec setInterval, vous devez g√©rer manuellement les cas o√π vous souhaitez arr√™ter l‚Äôintervalle, reprendre l‚Äôintervalle ou g√©rer des erreurs.

Par contre, avec l‚Äôop√©rateur interval de RxJS, vous obtenez un Observable qui √©met des √©v√©nements √† un intervalle r√©gulier. Cet Observable peut √™tre facilement compos√© avec d‚Äôautres Observables, manipul√© avec d‚Äôautres op√©rateurs, ou arr√™t√© ou repris √† tout moment. En cas d‚Äôerreur, vous pouvez g√©rer cela de mani√®re d√©clarative avec les op√©rateurs d‚Äôerreur.

Le v√©ritable pouvoir de RxJS r√©side dans la combinaison de ces op√©rateurs pour cr√©er des flux de donn√©es complexes et g√©rables de mani√®re tr√®s lisible et maintenable.

Par exemple, imaginez que vous souhaitez √©mettre un √©v√©nement toutes les secondes, mais seulement pendant les 10 premi√®res secondes. Avec setInterval, vous devriez mettre en place un compteur, un if pour v√©rifier le compteur, et un clearInterval pour arr√™ter l‚Äô√©mission. Avec RxJS, vous pouvez simplement combiner les op√©rateurs interval et take :

```ts
import { interval } from "rxjs";
import { take } from "rxjs/operators";

interval(1000).pipe(take(10)).subscribe(console.log);
```

Cela √©mettra un nombre croissant chaque seconde, de 0 √† 9. C‚Äôest la beaut√© de la programmation r√©active : vous d√©clarez ce que vous voulez faire, et RxJS s‚Äôoccupe du comment. Je pr√©pare un article sur la programmation r√©active qui devrait sortir au mois de juillet !

Ok, maintenant que l‚Äôintro est faite, d√©couvrons ensemble les op√©rateurs RxJS les plus fr√©quents qui vous suffiront pour 99% des sc√©narios.

#### Les op√©rateurs de cr√©ation

##### of()

Cet op√©rateur permet de cr√©er un Observable √† partir d‚Äôune valeur qu‚Äôon lui passe.

```ts
import { of } from "rxjs";

const products$ = of([
  { id: 1, name: "product1", price: 10 },
  { id: 2, name: "product2", price: 30 },
  { id: 3, name: "product3", price: 5 },
]).subscribe(console.log);
// affiche le tableau pass√© en argument.
```

Cela peut √™tre utile lorsque vous devez cr√©er rapidement un Observable √† partir de valeurs statiques, par exemple dans un service pour simuler une donn√©e qui viendrait du backend.

##### interval

Cr√©e un Observable qui √©met une s√©quence infinie de valeurs enti√®res √† intervalles r√©guliers.

```ts
import { interval } from "rxjs";

const counter = interval(1000).subscribe(console.log);
// affiche 0..1..2..3..4 chaque seconde
```

C‚Äôest utile pour cr√©er des compteurs, des d√©lais ou des intervalles de temps, par exemple pour une fonctionnalit√© de minuterie dans une application.

##### combineLatest

Cet op√©rateur combine les derni√®res valeurs de plusieurs Observables. Il √©met une nouvelle valeur chaque fois que l‚Äôun des Observables qu‚Äôil combine √©met une valeur. Il est √† noter que combineLatest ne va pas √©mettre tant que chacun de ses Observables n‚Äôa pas √©mis au moins une valeur.

```ts
import { combineLatest, of } from "rxjs";
import { delay } from "rxjs/operators";

const products$ = http.get("api/products");
const orders$ = http.get("api/orders");
const result$ = combineLatest({ products: products$, orders: orders$ });

result$.subscribe(({ products, orders }) => {
  console.log(products);
  console.log(orders);
});
```

C‚Äôest pratique lorsque vous voulez combiner les r√©sultats de plusieurs requ√™tes HTTP ou lorsque vous souhaitez synchroniser plusieurs flux de donn√©es pour faire une op√©ration bas√©e sur plusieurs flux.

##### merge

Cet op√©rateur combine plusieurs Observables en un seul, en √©mettant les valeurs de chaque Observable d√®s qu‚Äôelles sont disponibles.

```ts
import { merge, of } from "rxjs";
import { delay } from "rxjs/operators";

const obs1 = of("Hello");
const obs2 = of("World").pipe(delay(1000));
const merged = merge(obs1, obs2);

merged.subscribe((value) => console.log(value));
// Affiche 'Hello', puis 'World' apr√®s un d√©lai
```

Utile lorsque vous voulez fusionner plusieurs flux de donn√©es en un seul, par exemple lors de l‚Äôagr√©gation de donn√©es √† partir de plusieurs sources de donn√©es dans divers services.

##### defer

Il permet de retarder la cr√©ation de l'Observable jusqu'√† ce qu'un Observateur s'y abonne. Cela signifie que l'Observable n'est cr√©√© qu'au moment de l'abonnement, ce qui permet de s'assurer que l'Observable encapsule toujours les donn√©es les plus √† jour.

```ts
import { defer } from "rxjs";

const currentTime$ = defer(() => of(new Date().getTime()));

currentTime$.subscribe(console.log);
// üëÜ m'affiche bien le moment actuel
// qu'importe √† quel moment je subscribe
// si j'avais utilis√© simplement of(new Date().getTime())
// alors cela m'aurait retourn√© le m√™me r√©sultat √† chaque subscribe
```

C‚Äôest utile quand vous voulez retarder l‚Äôex√©cution de la fonction qui g√©n√®re l‚ÄôObservable jusqu‚Äô√† ce qu‚Äôun abonn√© soit pr√©sent.

#### Les op√©rateurs de r√©action

##### map

Cet op√©rateur est utilis√© pour appliquer une fonction √† chaque valeur √©mise par l‚ÄôObservable source.

```ts
import { of } from "rxjs";
import { map } from "rxjs/operators";

const nums = of(1, 2, 3);
const squareNums = nums.pipe(map((n) => n * n));

squareNums.subscribe((x) => console.log(x)); // Affiche 1, 4, 9
```

C‚Äôest utile lorsque vous voulez transformer les donn√©es re√ßues d‚Äôun Observable, par exemple pour reformater les donn√©es re√ßues d‚Äôune API.

##### mergeMap

Il permet de g√©rer les situations o√π on voudrait subscribe dans un subscribe. C‚Äôest √† dire les situations o√π les valeurs √©mient par le flux de donn√©es sont elles-m√™mes des Observable ou bien qu‚Äôon veut renvoyer un Observable gr√¢ce √† la donn√©e √©mise. mergeMap va s‚Äôabonner √† la valeur et renvoyer le r√©sultat de l‚Äôabonnement.

```ts
import { mergeMap } from 'rxjs/operators';

@Component(...)
export class AppComponent {
  http = inject(HttpClient);
  productID$ = new FormControl();

  product$ = productID$.pipe(
    mergeMap(productID => this.http.get(`api/products/${productID}`))
  )
}
```

Il est particuli√®rement utile pour g√©rer les sc√©narios o√π chaque valeur √©mise par un Observable est elle-m√™me un Observable, comme lors de l‚Äôenvoi de requ√™tes HTTP en r√©ponse √† des √©v√©nements de l‚Äôutilisateur.

##### switchMap

Cet op√©rateur est similaire √† mergeMap(), mais annule les valeurs pr√©c√©dentes chaque fois qu'une nouvelle valeur est √©mise.

```ts
import { switchMap } from 'rxjs/operators';

@Component(...)
export class AppComponent {
  http = inject(HttpClient);
  productID$ = new FormControl();

  // si productID$ √©met avant que le http.get se termine
  // alors le call HTTP sera cancel et remplac√© par le suivant
  product$ = productID$.pipe(
    switchMap(productID => this.http.get(`api/products/${productID}`))
  )
}
```

C‚Äôest pratique lorsque vous voulez ignorer les anciennes valeurs en faveur des nouvelles, par exemple lors de l‚Äôimpl√©mentation d‚Äôune fonction de recherche autocompl√®te o√π seule la derni√®re requ√™te est pertinente.

##### exhaustMap

Cet op√©rateur est aussi similaire √† mergeMap(), mais il ignore les nouvelles valeurs tant que chaque valeur √©mise n'a pas termin√©.

```ts
import { exhaustMap } from 'rxjs/operators';

@Component(...)
export class AppComponent {
  http = inject(HttpClient);
  productID$ = new FormControl();

  // si productID$ √©met avant que le http.get se termine
  // alors cette √©mission sera ignor√©e
  product$ = productID$.pipe(
    exhaustMap(productID => this.http.get(`api/products/${productID}`))
  )
}
```

C‚Äôest utile dans des situations o√π vous voulez ignorer les nouvelles valeurs jusqu‚Äô√† ce que chaque valeur √©mise ait termin√© son traitement, comme lors de la gestion des clics sur un bouton pour emp√™cher les doubles soumissions.

##### filter

Cet op√©rateur √©met uniquement les valeurs qui satisfont une certaine condition.

```ts
import { of } from "rxjs";
import { filter } from "rxjs/operators";

const nums = of(1, 2, 3, 4, 5);
const evens = nums.pipe(filter((n) => n % 2 === 0));

evens.subscribe((x) => console.log(x)); // Affiche 2, 4
```

Il est utile lorsque vous voulez filtrer certains r√©sultats, par exemple en filtrant certaines entr√©es utilisateur ou certains r√©sultats d‚Äôune API.

##### scan

Cet op√©rateur fonctionne comme reduce() pour les tableaux. Il applique une fonction √† chaque valeur √©mise par l'Observable source et √©met le r√©sultat cumulatif.

```ts
import { of } from "rxjs";
import { scan } from "rxjs/operators";

const nums = of(1, 2, 3);
const sum = nums.pipe(scan((acc, curr) => acc + curr, 0));

sum.subscribe((x) => console.log(x)); // Affiche 1, 3, 6
```

C‚Äôest utile lorsque vous voulez accumuler des valeurs au fil du temps, par exemple pour calculer une somme totale ou pour construire un tableau de valeurs √©mises.

##### distinctUntilChanged

Cet op√©rateur √©met une valeur uniquement si elle est diff√©rente de la derni√®re valeur √©mise.

```ts
import { of } from "rxjs";
import { distinctUntilChanged } from "rxjs/operators";

const nums = of(1, 1, 2, 2, 3, 3);
const distinctNums = nums.pipe(distinctUntilChanged());

distinctNums.subscribe((x) => console.log(x)); // Affiche 1, 2, 3
```

C‚Äôest utile lorsque vous voulez ignorer les valeurs en double, par exemple lorsqu'on cr√©√© un strore fait-maison ou chaque selector utilise distinctUntilChanged() pour √©viter d‚Äô√©mettre √† nouveau si la valeur est la m√™me.

##### tap

Cet op√©rateur est utilis√© pour effectuer des effets de bord. Il applique une fonction √† chaque valeur √©mise par l‚ÄôObservable source, mais retourne la valeur sans la modifier.

```ts
import { of } from "rxjs";
import { tap } from "rxjs/operators";

const nums = of(1, 2, 3).pipe(tap(console.log)).subscribe();
```

C‚Äôest utile lorsque vous voulez d√©clencher une action secondaire en r√©action √† une valeur √©mise, la mise √† jour d‚Äôun √©tat (loader par exemple) ou un console.log() pour regarder l‚Äô√©tat du flux.

##### delay

Permet de d√©caler le moment o√π les valeurs √©mises par un Observable sont r√©ellement √©mises. Cela retarde essentiellement l'√©mission de chaque valeur d'un certain nombre de millisecondes.

```ts
import { delay } from "rxjs/operators";

const data$ = of({ some: "data" });

data$.pipe(delay(2000)).subscribe(console.log);
// affiche l'objet pass√© en param√®tre mais au bout de 2 secondes
```

C‚Äôest utile lorsque vous voulez retarder une action, comme l‚Äôaffichage d‚Äôun message de succ√®s apr√®s une action de l‚Äôutilisateur.

##### take

Cet op√©rateur n‚Äô√©met que les n premi√®res valeurs puis compl√®te l'Observable.

```ts
import { interval } from "rxjs";
import { take } from "rxjs/operators";

const numbers = interval(1000);
const takeFourNumbers = numbers.pipe(take(4));

takeFourNumbers.subscribe(console.oog);
// Affiche la valeur quatre fois puis se compl√®te
```

C‚Äôest utile lorsque vous ne voulez traiter qu‚Äôun certain nombre de valeurs, comme pour paginer les r√©sultats d‚Äôune requ√™te ou limiter le nombre de tentatives d‚Äôune action.

##### takeUntil

Cet op√©rateur compl√®te l‚ÄôObservable d√®s qu‚Äôune autre Observable √©met une valeur.

```ts
import { interval, of } from "rxjs";
import { takeUntil, delay } from "rxjs/operators";

const numbers = interval(1000);
const stopper = of(true).pipe(delay(3500));
const takeUntilStopped = numbers.pipe(takeUntil(stopper));

takeUntilStopped.subscribe(console.log);
// Affiche la valeur jusqu'√† ce que stopper √©mette une valeur
```

C‚Äôest utile lorsque vous voulez arr√™ter une action d√®s qu‚Äôun autre √©v√©nement se produit, comme arr√™ter un intervalle lorsqu‚Äôun utilisateur clique sur un bouton ou unsubscribe d‚Äôun flux.

##### takeWhile

Cet op√©rateur √©met des valeurs tant qu‚Äôune condition est vraie et compl√®te l‚ÄôObservable d√®s que la condition devient fausse.

```ts
import { interval } from "rxjs";
import { takeWhile } from "rxjs/operators";

const numbers = interval(1000);
const takeWhileLessThanFive = numbers.pipe(takeWhile((n) => n < 5));

takeWhileLessThanFive.subscribe(console.log);
// Affiche la valeur tant que n est inf√©rieur √† 5
```

C‚Äôest utile lorsque vous voulez continuer √† √©mettre des valeurs en fonction d‚Äôune condition, comme arr√™ter un d√©filement automatique quand l‚Äôutilisateur atteint le bas de la page.

##### skip

Cet op√©rateur ignore les n premi√®res valeurs √©mises par l'Observable source.

```ts
import { interval } from "rxjs";
import { skip } from "rxjs/operators";

const numbers = interval(1000);
const skipTwoNumbers = numbers.pipe(skip(2));

skipTwoNumbers.subscribe(console.log);
// Ignore les deux premi√®res valeurs
```

C‚Äôest utile lorsque vous voulez ignorer les premi√®res valeurs, comme lors de la mise en place d‚Äôune fonction de pagination.

##### debounceTime

Cet op√©rateur n‚Äô√©met une valeur que si un certain temps s‚Äôest √©coul√© sans qu‚Äôune autre valeur soit √©mise.

```ts
import { debounceTime } from "rxjs/operators";

inputFormControl = new FormControl();

inputFormControl.valueChanges.pipe(debounceTime(300)).subscribe(console.log);
// √âmet une valeur 300ms apr√®s la derni√®re saisie de l'utilisateur
```

C‚Äôest utile lorsque vous voulez limiter le taux de traitement, comme pour √©viter de faire trop de requ√™tes pendant la frappe de l‚Äôutilisateur dans une recherche en direct.

##### catchError

Cet op√©rateur attrape les erreurs sur l‚ÄôObservable source et permet de renvoyer un nouvel Observable.

```ts
import { catchError } from 'rxjs/operators';

@Component(...)
export class AppComponent {
  http = inject(HttpClient);

  products$ = this.http.get('api/products').pipe(
      catchError(error => {
        console.error('Une erreur est survenue lors de la r√©cup√©ration des donn√©es :', error);
        // On peut afficher un message d'erreur √©galement

        // On retourne un Observable avec des donn√©es par d√©faut en cas d'erreur
        return of({ data: 'Donn√©es par d√©faut' });
      })
    );

}

```

C‚Äôest utile lorsque vous voulez g√©rer les erreurs et peut-√™tre remplacer les valeurs erron√©es par des valeurs par d√©faut.

##### retry

Cet op√©rateur re-souscrit √† l‚ÄôObservable source si une erreur est produite, en permettant un certain nombre de tentatives.

```ts
import { retry } from 'rxjs/operators';

@Component(...)
export class AppComponent {
  http = inject(HttpClient);

  products$ = this.http.get('api/products').pipe(
    retry(3) // R√©essaye la requ√™te HTTP 3 fois en cas d'erreur
  );

}
```

C‚Äôest utile lorsque vous voulez r√©essayer une action en cas d‚Äôerreur, comme pour retenter une requ√™te HTTP qui a √©chou√©.

##### startWith

Cet op√©rateur fait en sorte que l‚ÄôObservable source commence par √©mettre une ou plusieurs valeurs sp√©cifiques.

```ts
import { of } from "rxjs";
import { startWith } from "rxjs/operators";

const numbers = of(1, 2, 3);
const startWithZero = numbers.pipe(startWith(0));

startWithZero.subscribe((x) => console.log(x)); // Affiche 0, 1, 2, 3
```

C‚Äôest utile lorsque vous voulez fournir des valeurs initiales, comme pour pr√©-remplir un champ de formulaire ou afficher une valeur par d√©faut pendant le chargement des donn√©es.

#### Conclusion

Les op√©rateurs RxJS sont des outils puissants qui nous permettent de manipuler et de contr√¥ler les flux de donn√©es dans nos applications Angular. Ils peuvent transformer les valeurs √©mises, filtrer les valeurs selon certaines conditions, retarder l‚Äô√©mission de valeurs, r√©p√©ter des flux de donn√©es, parmi tant d‚Äôautres op√©rations.

Le plus important n‚Äôest pas n√©cessairement de conna√Ætre tous les op√©rateurs mais avant tout de comprendre le logique

Nous avons explor√© les op√©rateurs les plus couramment utilis√©s dans ce deuxi√®me volet, chacun avec ses propres utilisations et avantages. Bien que nous ayons couvert beaucoup de terrain, il y a encore beaucoup plus d‚Äôop√©rateurs √† d√©couvrir. Je vous encourage √† explorer le site RxMarbes qui recense tous les op√©rateurs avec des diagrammes interactifs.
