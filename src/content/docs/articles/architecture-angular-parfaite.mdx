---
title: L'architecture Angular parfaite ?
description: L'architecture Angular parfaite ?
---

:::note
Cette article existe Ã©galement sur [Medium](https://medium.com/@kevin.tale/larchitecture-angular-parfaite-4ae7bd9335aa). <br />
S'il vous a plu, n'hÃ©sitez pas Ã  me laisser un (ou plusieurs) petit clap ğŸ˜‰
:::

> _â€œArchitectureâ€ ici fait rÃ©fÃ©rence Ã  la structure de fichiers, Ã  la faÃ§on dont vous la dÃ©coupez en diffÃ©rents composants, services, modules etc et de lâ€™endroit oÃ¹ vous les placez. Aussi, ce qui va suivre est basÃ© sur mon expÃ©rience personnelle, et doit Ãªtre considÃ©rÃ© comme une boÃ®te Ã  outils qui, comme toute approche, prÃ©sente des avantages et des inconvÃ©nients._

Chaque fois que je crÃ©e ou modifie une architecture Angular, je me pose **3 questions** :

1. Est-ce que les devsâ€™ trouveront mon architecture agrÃ©able Ã  utiliser au quotidien ?
2. Est-ce quâ€™elle pourra encaisser les Ã©volutions Ã  venir ?
3. Est-ce que mon architecture reflÃ¨te mon besoin mÃ©tier au mieux ?

Chacun de mes choix est confrontÃ© Ã  ces 3 questions.

Si les rÃ©ponses sont â€œouiâ€, alors je sais que mon architecture est parfaite, ou plutÃ´t quâ€™elle est **parfaitement adaptÃ©e Ã  mon contexte mÃ©tier actuel.**

Car oui, la rÃ©ponse Ã  ces 3 questions dÃ©pendent du logiciel que lâ€™on doit crÃ©er et de lâ€™Ã©quipe en charge. Ce que je veux dire par lÃ  câ€™est quâ€™une certaine architecture pourrait trÃ¨s bien fonctionner dans une situation mais pas une autre car le contexte mÃ©tier (quâ€™on appelle la complexitÃ© inhÃ©rente) est diffÃ©rent.
**Ainsi, deux architectures dans deux contextes diffÃ©rents peuvent varier drastiquement et il nâ€™existe pas dâ€™architecture qui couvre 100% des cas.**

Cependant, les 3 questions que jâ€™ai Ã©noncÃ© plus haut ainsi que des principes Ã©prouvÃ©es vont nous permettre dâ€™atteindre notre objectif : concevoir lâ€™architecture Angular parfaite pour **votre besoin**.

Dans cette article, nous allons tenter de comprendre **pourquoi ces questions sont importantes et surtout comment y rÃ©pondre !**

---

### Est-ce que mon architecture est agrÃ©able ?

Lâ€™agrÃ©abilitÃ© ressentie par les devs est primordiale dans vos architectures et doit Ãªtre au cÅ“ur de chacune de vos dÃ©cisions. Cela fait partie dâ€™un principe quâ€™on appelle la **Developer eXperience (DX)**. Câ€™est Ã  dire lâ€™aisance quâ€™ont les devs Ã  faire leur mÃ©tier.

Pour moi, la DX est la top prio. Nous vivons dans un milieu oÃ¹ les technologies et les besoins mÃ©tiers Ã©voluent constamment, lâ€™impact de Ã§a câ€™est que vous allez rÃ©guliÃ¨rement mettre votre code Ã  jour car lâ€™API dâ€™une librairie ou la version de votre framework ont changÃ©. Egalement, dâ€™un point de vue business, vos PO/PM vous demanderont dâ€™ajouter des fonctionnalitÃ©s ou dâ€™en modifier trÃ¨s rÃ©guliÃ¨rement. Bref, on passe nos journÃ©es Ã  modifier notre code et notre architecture de maniÃ¨re micro ou macro.

Et changer les choses dans une codebase câ€™est le dÃ©but des embrouilles :

- introduction de bugs dus Ã  des effets de bords
- lassitude, agacement ou inquiÃ©tudes des devs qui doivent replonger dans un code obscur

Une mauvaise architecture entraÃ®ne une mauvaise DX qui entraÃ®ne une Ã©quipe anxieuse et peu efficace. On aura peur de modifier les choses par incomprÃ©hension de la codebase et/ou on aura la flemme de â€œfaire propreâ€ car les patterns sont lourds : câ€™est le dÃ©but de la dette technique.

Ainsi, **lâ€™importance dâ€™avoir une architecture agrÃ©able Ã  utiliser est primordiale pour la santÃ© mentale des devs et donc la pÃ©rennitÃ© du business.**

Si lâ€™Ã©quipe de dÃ©veloppement trouve la structure de fichiers cohÃ©rentes et facile Ã  naviguer alors elle pourra ajouter, modifier ou supprimer des Ã©lÃ©ments plus rapidement et sans crainte dâ€™effet de bord.

Ce qui participe Ã©galement Ã  lâ€™agrÃ©abilitÃ© de navigation dans une architecture câ€™est de **garder le nombre de fichiers et dossiers bas tout en respectant la separation of concerns**. La multiplication de fichiers peut tout Ã  fait rÃ©pondre Ã  un besoin, mais elle peut Ã©galement Ãªtre vecteur dâ€™erreurs. On doit trouver des noms adÃ©quats, on doit faire attention Ã  ne pas mÃ©langer les responsabilitÃ©s des fichiers, et au-delÃ  de Ã§a cela apporte de la lourdeur Ã  la navigation entre fichiers.

AprÃ¨s tout, si Angular et NgRx sâ€™Ã©vertuent Ã  rÃ©duire le boilerplate de leurs produits, câ€™est parce quâ€™ils ont bien compris lâ€™importance dâ€™avoir un workspace lÃ©ger.

Ne vous mÃ©prenez pas sur ce que je dis, je ne vous incite pas Ã  avoir un seul gros composant, service ou store avec tout dedans. Je vous incite Ã  dÃ©couper les choses quand il y a rÃ©ellement une raison de le faire. Lorsque vous vous apprÃªtez Ã  dÃ©couper un fichier en plusieurs , posez vous la question du gain et utilisez votre bon sens. Gardez la separation of concerns comme indicateur.

Ne sous-estimez pas lâ€™importance de la DX. Câ€™est le nerf de la guerre. Posez vous la question de savoir si une nouvelle personne qui intÃ¨gre lâ€™Ã©quipe arriverait Ã  comprendre lâ€™architecture frontend en quelques minutes.

### Est-ce que mon architecture est Ã©volutive ?

Je le disais en introduction, les besoins mÃ©tier Ã©voluent en permanence. Une feature en plus, une autre utilisÃ©e Ã  plusieurs endroits qui devient un peu diffÃ©rente selon lÃ  oÃ¹ elle est consommÃ©e.

Le problÃ¨me câ€™est que ni les devs ni les PO/PM ne voient dans le futur, donc oubliez tout de suite lâ€™idÃ©e que vous ferez une architecture qui encaissera tous les changements futurs. Ca nâ€™arrivera pas.

Alors on pourrait se dire que de sortir lâ€™artillerie lourde dÃ¨s le dÃ©part est une bonne idÃ©e. Partons sur une architecture hexagonale en monorepo et full microfrontends. Au moins on aura quelque chose dâ€™Ã©volutif.

Câ€™est peut-Ãªtre le cas, mais cela implique que lâ€™Ã©quipe, incluant vous-mÃªme, soit **hautement** qualifiÃ©s pour entretenir ce genre dâ€™architecture. Et, spoiler alert, Ã§a nâ€™arrive pas non plus ou dans de trop rares cas.

**Une architecture Ã©volutive est avant tout quelque chose de facilement incrÃ©mentale et dont on a la maÃ®trise**. Câ€™est Ã  dire quelque chose qui diminue les contraintes : si on veut poser une nouvelle brique par dessus de maniÃ¨re isolÃ©e ou non, on peut le faire.

Si je devais donner un choix stratÃ©gique offrant beaucoup de valeurs sans demander une maturitÃ© technique dÃ©mesurÃ©e, câ€™est lâ€™utilisation dâ€™un **monorepo**.

Un monorepo, câ€™est le fait dâ€™avoir un seul repository git avec plusieurs apps et libs. Cela permet notamment de faciliter le partage et la rÃ©utilisation de code entre vos diffÃ©rentes briques techniques et de profiter dâ€™un Ã©cosystÃ¨me trÃ¨s Ã©volutif. Ma solution prÃ©fÃ©rÃ©e est NX.

NX est un Ã©cosystÃ¨me facilitant la mise en place et le maintient dâ€™architecture web. Vous profiterez de ses outils qui permettent dâ€™intÃ©grer facilement les outils et patterns populaires du web (Angular, React, Jest, Cypress, Storybookâ€¦). NX est surtout utilisÃ© dans les architectures monorepo mais vous pouvez tout Ã  fait utiliser NX pour une simple application.

Personnellement je lâ€™utilise beaucoup dans mon quotidien et contrairement Ã  ce quâ€™il se dit ce nâ€™est pas uniquement adaptÃ© aux gros projets. Mais ce nâ€™est pas trivial non plus, cela nÃ©cessite une bonne coordination entre les membres de lâ€™Ã©quipe.

Je prÃ©vois un article dÃ©diÃ© sur le sujet ! Stay tuned!

A part Ã§a, une erreur que je vois souvent et qui impacte nÃ©gativement lâ€™Ã©volutivitÃ©, câ€™est la mauvaise comprÃ©hension du principe **DRY** (Donâ€™t Repeat Yourself).

Jâ€™ai travaillÃ© pour une sociÃ©tÃ© qui fabriquait des logiciels en marque blanche. En gros, on avait plusieurs clients, chacun dÃ©sirant une application dÃ©diÃ©e avec certaines fonctionnalitÃ©s. Ces fonctionnalitÃ©s Ã©taient parfois les mÃªmes entre les diffÃ©rentes apps (donc pour les diffÃ©rents clients), parfois non, ou parfois câ€™Ã©tait les mÃªmes mais avec quelques diffÃ©rences subtiles. Donc les apps avaient quelques bases communes entre elles mais aussi beaucoup de spÃ©cificitÃ©s.

Le choix (qui avait Ã©tÃ© fait bien avant mon arrivÃ©) a Ã©tÃ© de concevoir une seul app Angular avec toutes les fonctionnalitÃ©s Ã  lâ€™intÃ©rieur, chaque client partageait les mÃªmes pages oÃ¹ un tas de if se trouvaient et un fichier de configs par client qui pilotait lâ€™activation des fonctionnalitÃ©s Ã  coup de shouldActivateThisFeature: true.

RÃ©sultat : on sâ€™est retrouvÃ©s avec une app gigantesque avec des fichiers de 3k lignes qui contenaient les diffÃ©rentes logiques des diffÃ©rents clients. Câ€™Ã©tait impossible Ã  tester, trÃ¨s difficile Ã  isoler et lâ€™Ã©volution Ã©tait trÃ¨s limitÃ©e.

Comment on en est arrivÃ© lÃ  ? Parce quâ€™il y a une incomprÃ©hension sur la dÃ©finition de DRY.

**Ce nâ€™est pas parce que quelque chose Ã  le mÃªme nom que câ€™est la mÃªme chose.**

Ici, les applications avaient le mÃªme nom, les pages et fonctionnalitÃ©s aussi, donc on a considÃ©rÃ© que câ€™Ã©tait la mÃªme chose. On a donc tout mis dans une seule et mÃªme app.

Une solution viable aurait Ã©tÃ© de faire une app distincte par client oÃ¹ chacune dâ€™entre elle dÃ©clarait son propre routing avec ses propres pages et de considÃ©rer chaque fonctionnalitÃ© comme une librairie consommable par les apps.

Pensez toujours Ã  respecter une separation of concerns dans vos applications. Si deux features semblent trÃ¨s similaires mais divergent en quelques points, câ€™est souvent le signal que ce sont en rÃ©alitÃ© deux features diffÃ©rentes.

### Est-ce que mon architecture reflÃ¨te mon besoin mÃ©tier ?

Ce point lÃ  est la rÃ©sultante des deux prÃ©cÃ©dents. En fait, une architecture qui reflÃ¨te le besoin mÃ©tier est la porte dâ€™entrÃ©e vers une architecture agrÃ©able et Ã©volutive.

Ceci est lâ€™un des principes du **DDD** (Domain Driven Design) : concevoir une application en suivant le contexte mÃ©tier. Cela veut dire que mon architecture est le reflet de mon business, si bien quâ€™un PO/PM devrait pouvoir se balader dans mon repository et comprendre son architecture (jâ€™exagÃ¨re un peu mais pas tant).

Il y a une phrase dâ€™Arnaud Lemaire que jâ€™aime beaucoup et qui rÃ©sume une architecture DDD rÃ©ussie : **des petits changements mÃ©tiers doivent entraÃ®ner des petits changements dans la codebase et des grands changements mÃ©tiers doivent entraÃ®ner des grands changements dans la codebase.**

Bon, ceci Ã©tant dit, je ne ferai pas une explication exhaustive du DDD, dÃ©jÃ  parce que Ã§a pourrait tenir dans un bouquin, mais aussi parce que je ne prÃ©tends pas pouvoir le faire. En revanche, je peux vous expliquer comment appliquer certains de ses principes Ã  la crÃ©ation dâ€™architecture !

Il y a notamment deux voies pour mettre en place une architecture qui suit la logique mÃ©tier :

1. un dÃ©coupage de dossiers qui suit la navigation utilisateur
2. de la colocation de code

Le premier point consiste Ã  avoir un folder `routes` avec les diffÃ©rentes routes de votre applications (vos pages). Et dans chacune des routes on a potentiellement des sous routes. En somme, le code de la page `domain.com/products-list` sera contenu dans `routes/products-list`. Certains frameworks disposent de ce principe de maniÃ¨re naturelle, par exemple NextJS ou AnalogJS. Câ€™est ce quâ€™on appelle le **file base routing**. Câ€™est trÃ¨s intÃ©ressant car ainsi la logique de notre structure de fichiers est liÃ©e et pilotÃ©e par le mÃ©tier, lâ€™Ã©volution de notre codebase sera donc toujours fait au mÃªme rythme que le mÃ©tier tout en ayant quelque chose de facilement comprÃ©hensible. Lâ€™avantage est que si vous avez un ticket de bug sur une page, vous saurez immÃ©diatement oÃ¹ intervenir.

Le second point concerne la colocation de code. Cela fait rÃ©fÃ©rence au fait de regrouper le code et les fichiers traitant du mÃªme domaine mÃ©tier au mÃªme niveau dans votre arborescence de fichiers Cela assure une comprÃ©hension claire des dÃ©pendances des diffÃ©rentes parties de votre code et des potentielles effets de bords.

Nous allons voir dans la section suivante des exemples dâ€™architectures qui mettent en pratique tous les principes Ã©numÃ©rÃ©es jusquâ€™ici.

### La mise en pratique

Je vous parlais de file base routing, voici comment faire lâ€™Ã©quivalent dans Angular en partant dâ€™une application en version 16 :

```
src/
    app/
        routes/
            login/
                login.route.ts
            my-account/
                profile/
                    profile.route.ts
                purchase-history/
                    purchase-history.route.ts
                my-account.route.ts
                my-account.routing.ts
            product/
                product.route.ts
            product-list/
                product-list.route.ts
        app.config.ts
        app.component.ts
        app.routing.ts
    index.html
    main.ts
 angular.json
 package.json
```

Ici, la structure de mes fichiers suit parfaitement la navigation de lâ€™utilisateur dans lâ€™application. Si je suis sur la page `domain.com/product` alors je sais immÃ©diatement oÃ¹ se trouve le code impliquÃ©. Et Ã  lâ€™intÃ©rieur de chaque folder on retrouve la route en question avec leurs sous routes Ã©ventuelles (câ€™est le cas pour `my-account`). Câ€™est le fichier `app.routing.ts` qui pilote le routing de premier niveau et celui de second niveau est gÃ©rÃ© par des fichiers comme `my-account.routing.ts` par exemple.

Câ€™est trÃ¨s pratique pour lâ€™agrÃ©abilitÃ© comme je le disais plus haut, si vous avez un bug sur une page alors vous pourrez identifier en un clin dâ€™Å“il oÃ¹ intervenir.
Vous avez sans doute remarquÃ© quelque chose : je ne suis pas la convention Angular et je nomme mes routes en xxx.route.ts. Cela me permet dâ€™identifier rapidement ce quâ€™est ce fichier plutÃ´t que de nommer tous mes composants xxx.component.ts. Je vous invite Ã  faire de mÃªme !

Maintenant, imaginez que vous avez un header et footer prÃ©sents sur toutes vos pages et que vous voulez en faire deux composants. Ces composants vont Ãªtre utilisÃ©s dans le `AppComponent`. Mais oÃ¹ allez vous les placer dans votre architecture ?

La rÃ©ponse est : au plus proche de lÃ  oÃ¹ ils sont utilisÃ©s. Câ€™est le principe de colocation de code !

```
src/
    app/
        routes/
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
    index.html
    main.ts
 angular.json
 package.json

ğŸ‘† Les composants sont au mÃªme niveau de leur endroit dâ€™utilisation
```

Ainsi, des `xxx.component.ts` vivant Ã  cÃ´tÃ© dâ€™un `xxx.route.ts` signifient quâ€™ils sont utilisÃ© dedans. Tout simplement ! Pas besoin dâ€™utiliser de dossier `shared` ou `core` dans ce cas-lÃ . Cela ne ferait que rajouter du bruit inutile.

Je suis cette mÃªme logique pour toutes les routes et pas uniquement pour les composants :

```
src/
    app/
        routes/
            login/
            my-account/
                profile/
                purchase-history/
                my-account.route.ts
                my-account.routing.ts
                sidebar.component.ts
            product/
            product-list/
                product-list.route.ts
                product-list.service.ts
                product-list.store.ts
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
        initializer.service.ts
        jwt.interceptor.ts
    index.html
    main.ts
angular.json
package.json
```

Et oui ! Je parie que vous nâ€™aviez jamais vu ce genre dâ€™approche avant. Et bien je peux vous assurer quâ€™aprÃ¨s avoir essayÃ© des tas dâ€™approche, celle-ci apporte la meilleure DX au quotidien et sur le long terme.
Ici donc, tout est aplati, on minimise les dossiers et on suit une rÃ¨gle simple : **les fichiers qui sont utilisÃ©s ensemble sont cÃ´te Ã  cÃ´te**.
Par exemple, jâ€™ai besoin de crÃ©er un `interceptor` pour ajouter mon token JWT Ã  chaque requÃªte HTTP. Cet `interceptor` est utilisÃ© dans mon `app.config.ts` donc je le place Ã  son niveau !
Il en va de mÃªme pour les `guards`, les `services` etc.

Câ€™est de la **colocation de code**. Le but est de comprendre en un clin dâ€™Å“il **les responsabilitÃ©s et dÃ©pendances de mes fichiers.**

Vous allez peut-Ãªtre vous dire quâ€™on va potentiellement avoir des dossiers avec 15 fichiers Ã  lâ€™intÃ©rieur, voire plus. En effet, et devinez quoi : **câ€™est vraiment pas grave, au contraire !**
Croyez moi, les devs comprendront bien plus vite ce dÃ©coupage lÃ  que dâ€™obscurs dossiers `core` ou autres qui entraÃ®nent des rÃ©flexions supplÃ©mentaires et donc de potentielles erreurs et câ€™est lÃ  que la dette technique sâ€™accumule.

Prenez ces conseils comme des indications, si votre Ã©quipe se sent plus Ã  lâ€™aise avec un dossier par-ci par-lÃ  alors faites le, mais gardez toujours en tÃªte la DX et de rÃ©duire les chances dâ€™augmenter la dette technique.

Bon, on garde les fichiers en commun ensemble au mÃªme endroit, trÃ¨s bien, mais quâ€™en est-il des Ã©lÃ©ments partagÃ©s ?

Typiquement :

- des composants UI
- des features
- des utilitaires

Une solution est un dossier `shared` au mÃªme niveau que `routes` qui contient les Ã©lÃ©ments partagÃ©s de lâ€™application.

```
src/
    app/
        routes/
        shared/
            components/
            features/
            utils/
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
        initializer.service.ts
        jwt.interceptor.ts
    index.html
    main.ts
angular.json
package.json
```

Ainsi en tant que dev, si un Ã©lÃ©ment est rÃ©utilisÃ© Ã  plusieurs endroits alors je le mettrais ici.

Par exemples les composants :

```
src/
    app/
        routes/
        shared/
            components/
                buttons/
                cards/
                form/
                    input/
                    textarea/
                table/
            features/
            utils/
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
        initializer.service.ts
        jwt.interceptor.ts
    index.html
    main.ts
angular.json
package.json
```

Ces composants reprÃ©sentent des Ã©lÃ©ments qui ne sont pas attachÃ©s Ã  la logique mÃ©tier exactement comme les composants de Angular Material par exemple.

Il existe des solutions encore plus puissantes comme les design system. Un design system gÃ¨re lâ€™ensemble de lâ€™apparence de votre mÃ©tier, on y trouve les composants, les styles et les rÃ¨gles UI. Une mÃ©thodologie Ã©prouvÃ©e pour la crÃ©ation de design system est lâ€™Atomic Design. Je nâ€™en parlerai pas ici car ce nâ€™est pas le sujet mais je vous invite Ã  faire vos propres recherches !

Pour les utilitaires, rien de bien compliquÃ©, on a des folders qui correspondent Ã  nos besoins utilitaires :

```
src/
    app/
        routes/
        shared/
            components/
            features/
            utils/
                converting/
                formatting/
                testing/
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
        initializer.service.ts
        jwt.interceptor.ts
    index.html
    main.ts
angular.json
package.json
```

Pour les features, câ€™est la mÃªme idÃ©e. Une feature est un regroupement dâ€™Ã©lÃ©ments mÃ©tiers **rÃ©utilisables**. Cela peut Ãªtre des stores, des services, de la UI ou mÃªme une combinaison de tout cela.

```
src/
    app/
        routes/
        shared/
            components/
            features/
                payment/
                    cart.component.ts
                    cart.store.ts
                    index.ts
                    payment.service.ts
                user/
                    has-role.guard.ts
                    index.ts
                    has-logged-in.guard.ts
                    user.store.ts
            utils/
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
        initializer.service.ts
        jwt.interceptor.ts
    index.html
    main.ts
angular.json
package.json
```

Dans cette exemple nous avons deux features, payment et user. Chacun ayant un `index.ts` pour exposer lâ€™API aux consommateurs.
On peut facilement imaginer que dans mon application jâ€™ai besoin des informations du `user` Ã  plusieurs endroits, ainsi jâ€™importe ce dont jâ€™ai besoin depuis la feature `user`. Il en va de mÃªme pour `payment`, le service pourrait exposer des mÃ©thodes de paiement dÃ©clenchable Ã  plusieurs endroits de mon application, et on peut imaginer que le `cart` soit affichable Ã  plusieurs endroits Ã©galement.

**Important** : entendons nous bien, je possÃ¨de un folder `shared` mais pas de `SharedModule` ou que sais-je encore. Le folder shared apporte lâ€™indication que les Ã©lÃ©ments Ã  lâ€™intÃ©rieur sont rÃ©utilisÃ©s Ã  plusieurs endroits, mais pas quâ€™ils sont tous packagÃ©s ensemble ! Ils ont tous leurs propres responsabilitÃ©s et ne communique pas ensemble, comme les Ã©lÃ©ments dans `routes` par exemple.

Bref, chaque feature est un sous-ensemble de mon domaine dâ€™application et contient des Ã©lÃ©ments rÃ©utilisables. Dans lâ€™idÃ©e si une fonctionnalitÃ© Ã©merge pour une seule page de lâ€™application alors elle ne devrait pas Ãªtre dans `shared/features/xxx`. Par exemple si un administrateur Ã  la possibilitÃ© de supprimer un user en faisant un `http.delete` sur un endpoint `user/${id}` via une page `admin/delete-users` alors **en thÃ©orie** cette logique devrait Ãªtre contenue dans `routes/admin/delete-users/delete-users.service.ts`. Donc pas dans la feature `user` car cette fonctionnalitÃ© nâ€™est pas partagÃ©e.

Je dis bien â€œen thÃ©orieâ€ car câ€™est typiquement sur ce genre de choix oÃ¹ on va adapter son architecture selon le mÃ©tier et les prÃ©fÃ©rences de lâ€™Ã©quipe, on pourrait prÃ©fÃ©rer mettre cette logiquement Ã©galement dans la feature user pour certaines raisons. Et en poussant lâ€™idÃ©e un peu plus loin, on pourrait mÃªme avoir ceci :

```
src/
    app/
        design-system/
            components/
                buttons/
                cards/
                form/
                table/
            styles/
        features/
            payment/
            user/
        routes/
            login/
            my-account/
            product/
            product-list/
        utils/
            converting/
            formatting/
            testing/
        app.config.ts
        app.component.ts
        app.routing.ts
        footer.component.ts
        header.component.ts
        initializer.service.ts
        jwt.interceptor.ts
    index.html
    main.ts
angular.json
package.json
```

Ici, jâ€™ai carrÃ©ment fait sauter la notion de `shared`. Les composants sont dÃ©placÃ©s dans un `design-system`, `utils` est directement Ã  la racine ainsi que `features` signifiant quâ€™ils pourraient Ãªtre partagÃ©s ou non.

Câ€™est, Ã  mon sens, une architecture trÃ¨s solide (hormis monorepo) si lâ€™Ã©quipe Ã  un haut niveau de maturitÃ©. Le risque rÃ©side dans le fait de perturber lâ€™agrÃ©abilitÃ© au quotidien, jâ€™imagine facilement quâ€™une feature devienne mal isolÃ©e et quâ€™on y introduise des notions qui ne devraient pas y Ãªtre. PrÃ©fÃ©rez la colocation de code tant que câ€™est possible.

### Pour aller plus loin

Il y a beaucoup de mÃ©thodologies dont je nâ€™ai pas parlÃ© :

- microfrontends
- clean architecture
- architecture hexagonale

Ce sont des sujets poussÃ©s et qui nÃ©cessite un haut niveau de maturitÃ© technique mais qui peuvent apporter beaucoup Ã  la pÃ©rennitÃ© de vos projets. Assurez vous de maÃ®triser les points prÃ©cÃ©dents avant pour comprendre lâ€™essence dâ€™une bonne architecture avant de vous lancer dans ces recherches.

### RÃ©sumÃ©

- Pensez toujours Ã  vos collÃ¨gues qui rÃ©cupÃ¨reront votre code en priorisant la DX
- Si je reÃ§ois un ticket qui me dit â€œil y a un bug sur cette featureâ€, je dois trouver oÃ¹ intervenir en quelques secondes
- Si une nouvelle personne intÃ¨gre lâ€™Ã©quipe (et quelque soit son niveau de sÃ©nioritÃ© Ã  peu de chose prÃ¨s) alors elle doit comprendre lâ€™architecture en quelques minutes
- Lâ€™organisation de vos fichiers doit Ãªtre logique et consistant
- MÃ©fiez vous du DRY qui est parfois trompeur
- Mettez un folder routes qui suivra la navigation de lâ€™utilisateur
- Aplatissez vos fichiers et utilisez de la colocation de code au maximum tant que cela respecte la separation of concerns
- Utilisez un dossier shared pour y mettre des sous dossiers components, utils, features etc contenant vos Ã©lÃ©ments partagÃ©s
- Alternativement, vous pouvez mettre ces sous dossiers directement Ã  la racine au mÃªme niveau que routes
- ConsidÃ©rez sÃ©rieusement lâ€™approche monorepo avec NX

### Conclusion

Une architecture parfaite **pour votre business** mettra du temps Ã  Ãªtre mise en place. Il faudra faire, dÃ©faire et refaire rÃ©guliÃ¨rement. Mais si vous suivez ces conseils et que vous priorisez la DX alors tout ce passera pour le mieux et vos collÃ¨gues et clients/responsables vous remercieront !
